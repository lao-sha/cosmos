# å…«å­—æ•°æ® JSON æ¸…å•å­˜å‚¨è®¾è®¡

> æ–‡æ¡£æ—¥æœŸ: 2026-01-23  
> ç‰ˆæœ¬: 2.0 (OCW + TEE ç»“åˆæ¶æ„)  
> çŠ¶æ€: è®¾è®¡æ–¹æ¡ˆ

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰å…«å­—æ•°æ® JSON æ¸…å•å­˜å‚¨æ–¹æ¡ˆï¼Œé‡‡ç”¨ **OCW + TEE ç»“åˆæ¶æ„**ï¼š
- **OCW**: è´Ÿè´£è¯·æ±‚è°ƒåº¦ã€TEE è°ƒç”¨ã€IPFS å­˜å‚¨ã€é“¾ä¸Šæäº¤
- **TEE**: è´Ÿè´£éšç§è®¡ç®—ï¼ˆè§£å¯†ã€å…«å­—è®¡ç®—ã€åŠ å¯†ã€ç­¾åï¼‰

---

## æ¶æ„æ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OCW + TEE ç»“åˆæ¶æ„                                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  å‰ç«¯    â”‚â”€â”€â”€>â”‚  é“¾ä¸Š    â”‚â”€â”€â”€>â”‚   OCW    â”‚â”€â”€â”€>â”‚   TEE    â”‚          â”‚
â”‚  â”‚ (åŠ å¯†)   â”‚    â”‚ (å­˜å‚¨)   â”‚    â”‚ (è°ƒåº¦)   â”‚    â”‚ (è®¡ç®—)   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â”‚                              â”‚ â–²              â”‚                  â”‚
â”‚       â”‚                              â”‚ â”‚              â”‚                  â”‚
â”‚       â”‚                              â–¼ â”‚              â”‚                  â”‚
â”‚       â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚                  â”‚
â”‚       â”‚                         â”‚  IPFS    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚       â”‚                         â”‚ (å­˜å‚¨)   â”‚    åŠ å¯† JSON               â”‚
â”‚       â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚       â”‚                              â”‚                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚              ç”¨æˆ·è§£å¯†æŸ¥çœ‹                                                â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### èŒè´£åˆ’åˆ†

| ç»„ä»¶ | èŒè´£ | æ¥è§¦æ˜æ–‡ |
|------|------|----------|
| **å‰ç«¯** | å¯†é’¥ç”Ÿæˆã€åŠ å¯†è¾“å…¥ã€è§£å¯†ç»“æœ | âœ… æ˜¯ |
| **é“¾ä¸Š** | å­˜å‚¨è¯·æ±‚ã€å­˜å‚¨ç»“æœã€äº‹ä»¶è§¦å‘ | âŒ å¦ |
| **OCW** | è½®è¯¢è¯·æ±‚ã€è°ƒç”¨ TEEã€ä¸Šä¼  IPFSã€æäº¤ç»“æœ | âŒ å¦ |
| **TEE** | è§£å¯†è¾“å…¥ã€å…«å­—è®¡ç®—ã€ç”Ÿæˆ JSONã€åŠ å¯†è¾“å‡º | âœ… æ˜¯ï¼ˆéš”ç¦»ï¼‰ |
| **IPFS** | å­˜å‚¨åŠ å¯† JSON | âŒ å¦ |

---

## éšç§æ¨¡å¼

ç”¨æˆ·å¯é€‰æ‹©éšç§çº§åˆ«ï¼š

| æ¨¡å¼ | é“¾ä¸Šå…¬å¼€ | IPFS å†…å®¹ | é€‚ç”¨åœºæ™¯ |
|------|----------|-----------|----------|
| **Public** | sizhu_index + gender | æ˜æ–‡ JSON | å…¬å¼€å‘½ç›˜å±•ç¤º |
| **Encrypted** | sizhu_index + gender | åŠ å¯† JSON | ä¸ªäººéšç§å‘½ç›˜ |
| **Private** | æ—  | åŠ å¯† JSON | æœ€é«˜éšç§éœ€æ±‚ |

```rust
#[derive(Clone, Copy, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum PrivacyMode {
    /// å…¬å¼€æ¨¡å¼ï¼šé“¾ä¸Šå­˜å‚¨ sizhu_indexï¼ŒIPFS æ˜æ–‡
    Public = 0,
    /// åŠ å¯†æ¨¡å¼ï¼šé“¾ä¸Šå­˜å‚¨ sizhu_indexï¼ŒIPFS åŠ å¯†
    Encrypted = 1,
    /// ç§å¯†æ¨¡å¼ï¼šé“¾ä¸Šä¸å­˜å‚¨ sizhu_indexï¼ŒIPFS åŠ å¯†
    Private = 2,
}
```

---

## é“¾ä¸Šå­˜å‚¨ç»“æ„

```rust
/// ç»Ÿä¸€çš„å…«å­—é“¾ä¸Šå­˜å‚¨ï¼ˆæ”¯æŒæ‰€æœ‰éšç§æ¨¡å¼ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct BaziOnChain<T: Config> {
    /// æ‰€æœ‰è€…
    pub owner: T::AccountId,
    
    /// éšç§æ¨¡å¼
    pub privacy_mode: PrivacyMode,
    
    /// å››æŸ±ç´¢å¼•ï¼ˆPrivate æ¨¡å¼ä¸‹ä¸º Noneï¼‰
    pub sizhu_index: Option<SiZhuIndex>,
    
    /// æ€§åˆ«ï¼ˆPrivate æ¨¡å¼ä¸‹ä¸º Noneï¼‰
    pub gender: Option<Gender>,
    
    /// JSON æ¸…å• CIDï¼ˆIPFSï¼‰
    pub manifest_cid: BoundedVec<u8, ConstU32<64>>,
    
    /// æ¸…å•å“ˆå¸Œï¼ˆç”¨äºéªŒè¯å®Œæ•´æ€§ï¼‰
    pub manifest_hash: [u8; 32],
    
    /// ç”Ÿæˆæ–¹å¼
    pub generation: GenerationInfo<T>,
    
    /// ç‰ˆæœ¬å·ï¼ˆç”¨äºæ›´æ–°è¿½æº¯ï¼‰
    pub version: u32,
    
    /// åˆ›å»ºåŒºå—
    pub created_at: BlockNumberFor<T>,
    
    /// æ›´æ–°åŒºå—
    pub updated_at: BlockNumberFor<T>,
}

/// ç”Ÿæˆä¿¡æ¯
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum GenerationInfo<T: Config> {
    /// OCW ç”Ÿæˆï¼ˆå…¬å¼€æ¨¡å¼ï¼‰
    Ocw,
    /// TEE ç”Ÿæˆï¼ˆåŠ å¯†/ç§å¯†æ¨¡å¼ï¼‰
    Tee {
        /// TEE èŠ‚ç‚¹
        node: T::AccountId,
        /// è®¡ç®—è¯æ˜
        proof: ComputationProof,
    },
}
```

### å­˜å‚¨å¤§å°å¯¹æ¯”

| æ¨¡å¼ | é“¾ä¸Šå¤§å° | è¯´æ˜ |
|------|----------|------|
| **Public** | ~100 bytes | sizhu_index + gender + cid + hash |
| **Encrypted** | ~150 bytes | åŒä¸Š + TEE proof |
| **Private** | ~140 bytes | æ—  sizhu_index + TEE proof |

---

## å¾…å¤„ç†è¯·æ±‚ç»“æ„

```rust
/// å¾…å¤„ç†çš„å…«å­—è¯·æ±‚
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct PendingBaziRequest<T: Config> {
    /// è¯·æ±‚è€…
    pub requester: T::AccountId,
    /// è¾“å…¥æ•°æ®ï¼ˆPublic æ¨¡å¼ä¸ºæ˜æ–‡ï¼Œå…¶ä»–ä¸ºå¯†æ–‡ï¼‰
    pub input_data: InputData,
    /// ç”¨æˆ·å…¬é’¥ï¼ˆç”¨äºåŠ å¯†è¿”å›ç»“æœï¼ŒPublic æ¨¡å¼ä¸º Noneï¼‰
    pub user_pubkey: Option<[u8; 32]>,
    /// éšç§æ¨¡å¼
    pub privacy_mode: PrivacyMode,
    /// åˆ†é…çš„ TEE èŠ‚ç‚¹ï¼ˆPublic æ¨¡å¼ä¸º Noneï¼‰
    pub assigned_node: Option<T::AccountId>,
    /// è¯·æ±‚çŠ¶æ€
    pub status: RequestStatus,
    /// é‡è¯•æ¬¡æ•°
    pub retry_count: u8,
    /// åˆ›å»ºåŒºå—
    pub created_at: BlockNumberFor<T>,
}

/// è¾“å…¥æ•°æ®ï¼ˆåŒºåˆ†æ˜æ–‡å’Œå¯†æ–‡ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum InputData {
    /// æ˜æ–‡è¾“å…¥ï¼ˆPublic æ¨¡å¼ï¼‰
    Plaintext(BaziInputPlain),
    /// åŠ å¯†è¾“å…¥ï¼ˆEncrypted/Private æ¨¡å¼ï¼‰
    Encrypted(EncryptedData),
}

/// æ˜æ–‡å…«å­—è¾“å…¥
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct BaziInputPlain {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub gender: Gender,
    pub longitude: Option<i32>,
}

/// åŠ å¯†æ•°æ®
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct EncryptedData {
    pub ciphertext: BoundedVec<u8, ConstU32<256>>,
    pub nonce: [u8; 24],
    pub sender_pubkey: [u8; 32],
}

/// è¯·æ±‚çŠ¶æ€
#[derive(Clone, Copy, Debug, Encode, Decode, TypeInfo, MaxEncodedLen, PartialEq)]
pub enum RequestStatus {
    /// å¾…å¤„ç†
    Pending,
    /// å¤„ç†ä¸­
    Processing,
    /// å·²å®Œæˆ
    Completed,
    /// å¤±è´¥ï¼ˆå¯é‡è¯•ï¼‰
    Failed,
    /// è¶…æ—¶
    Timeout,
}
```

---

## JSON æ¸…å•ç»“æ„

### æ˜æ–‡æ¨¡å¼ï¼ˆPublicï¼‰

```json
{
  "version": "1.0",
  "schema": "bazi-manifest-v1",
  "created_at": "2026-01-23T08:42:00Z",
  
  "metadata": {
    "name": "å¼ ä¸‰å‘½ç›˜",
    "privacy_mode": "public",
    "generated_by": "ocw"
  },
  
  "sizhu": {
    "year": {
      "gan": "ç”²", "gan_index": 0,
      "zhi": "å­", "zhi_index": 0,
      "ganzhi": "ç”²å­", "ganzhi_index": 0,
      "nayin": "æµ·ä¸­é‡‘",
      "canggan": [{ "gan": "ç™¸", "type": "ä¸»æ°”", "weight": 100, "shishen": "æ­£å°" }]
    },
    "month": { ... },
    "day": { ... },
    "hour": { ... },
    "rizhu": { "gan": "æˆŠ", "wuxing": "åœŸ" }
  },
  
  "dayun": {
    "qiyun_age": 3,
    "qiyun_year": 1987,
    "is_shun": true,
    "steps": [...]
  },
  
  "analysis": {
    "wuxing_strength": { "jin": 120, "mu": 180, "shui": 90, "huo": 150, "tu": 200, "total": 740 },
    "xiyong_shen": "æ°´",
    "jiyong_shen": "ç«",
    "body_strength": "èº«æ—º"
  }
}
```

### åŠ å¯†æ¨¡å¼ï¼ˆEncrypted / Privateï¼‰

```json
{
  "version": "1.0",
  "schema": "bazi-manifest-encrypted-v1",
  "algorithm": "AES-256-GCM",
  "nonce": "base64_nonce...",
  "enclave_pubkey": "base64_pubkey...",
  "ciphertext": "base64_encrypted_full_manifest..."
}
```

---

## å®Œæ•´æµç¨‹è¯¦è§£

### Phase 1: ç”¨æˆ·æäº¤è¯·æ±‚ï¼ˆå‰ç«¯ï¼‰

```typescript
const birthData = {
  year: 1990, month: 5, day: 15, hour: 10,
  gender: 0,  // 0=male, 1=female
  longitude: null,
};

// ========== Public æ¨¡å¼ï¼šæ˜æ–‡æäº¤ ==========
async function createBaziPublic(birthData: BirthInput) {
  // æ— éœ€åŠ å¯†ï¼Œç›´æ¥æäº¤æ˜æ–‡
  await api.tx.bazi.createBaziPublic(
    birthData.year,
    birthData.month,
    birthData.day,
    birthData.hour,
    birthData.gender,
    birthData.longitude,
  ).signAndSend(account);
}

// ========== Encrypted/Private æ¨¡å¼ï¼šåŠ å¯†æäº¤ ==========
async function createBaziPrivate(birthData: BirthInput, privacyMode: PrivacyMode) {
  // 1. è·å– TEE èŠ‚ç‚¹å…¬é’¥
  const teeNodes = await api.query.teePrivacy.activeNodes.entries();
  const enclavePubkey = teeNodes[0][1].enclave_pubkey;

  // 2. ç”Ÿæˆ/åŠ è½½ç”¨æˆ·å¯†é’¥å¯¹ï¼ˆè§"å¯†é’¥ç®¡ç†"ç« èŠ‚ï¼‰
  const userKeyPair = await getUserKeyPair(account);

  // 3. ECDH åŠ å¯†å‡ºç”Ÿæ—¶é—´
  const plaintext = JSON.stringify(birthData);
  const nonce = randomBytes(24);
  const encrypted = nacl.box(
    new TextEncoder().encode(plaintext),
    nonce,
    enclavePubkey,
    userKeyPair.secretKey
  );

  // 4. æäº¤é“¾ä¸Šè¯·æ±‚
  await api.tx.bazi.createBazi(
    { ciphertext: Array.from(encrypted), nonce: Array.from(nonce), sender_pubkey: Array.from(userKeyPair.publicKey) },
    Array.from(userKeyPair.publicKey),  // ç”¨äºåŠ å¯†è¿”å›ç»“æœ
    privacyMode,
  ).signAndSend(account);
}

// ========== ç»Ÿä¸€å…¥å£ ==========
async function createBazi(birthData: BirthInput, privacyMode: PrivacyMode) {
  if (privacyMode === PrivacyMode.Public) {
    await createBaziPublic(birthData);
  } else {
    await createBaziPrivate(birthData, privacyMode);
  }
}
```

### Phase 2: é“¾ä¸Šå¤„ç†ï¼ˆRuntimeï¼‰

```rust
// ========== Public æ¨¡å¼ï¼šæ˜æ–‡æäº¤ ==========
#[pallet::call_index(0)]
pub fn create_bazi_public(
    origin: OriginFor<T>,
    year: u16,
    month: u8,
    day: u8,
    hour: u8,
    gender: Gender,
    longitude: Option<i32>,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    let request_id = Self::next_request_id();
    
    // Public æ¨¡å¼ï¼šæ˜æ–‡å­˜å‚¨ï¼Œæ— éœ€ TEE
    PendingRequests::<T>::insert(request_id, PendingBaziRequest {
        requester: who.clone(),
        input_data: InputData::Plaintext(BaziInputPlain { year, month, day, hour, gender, longitude }),
        user_pubkey: None,
        privacy_mode: PrivacyMode::Public,
        assigned_node: None,
        status: RequestStatus::Pending,
        retry_count: 0,
        created_at: Self::current_block(),
    });
    
    Self::deposit_event(Event::BaziRequestSubmitted {
        request_id,
        requester: who,
        privacy_mode: PrivacyMode::Public,
        assigned_node: None,
    });
    
    Ok(())
}

// ========== Encrypted/Private æ¨¡å¼ï¼šåŠ å¯†æäº¤ ==========
#[pallet::call_index(1)]
pub fn create_bazi(
    origin: OriginFor<T>,
    encrypted_input: EncryptedData,
    user_pubkey: [u8; 32],
    privacy_mode: PrivacyMode,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // éªŒè¯éšç§æ¨¡å¼
    ensure!(privacy_mode != PrivacyMode::Public, Error::<T>::UsePublicExtrinsic);
    
    let request_id = Self::next_request_id();
    
    // åˆ†é… TEE èŠ‚ç‚¹
    let assigned_node = Self::select_active_tee_node()?;
    
    PendingRequests::<T>::insert(request_id, PendingBaziRequest {
        requester: who.clone(),
        input_data: InputData::Encrypted(encrypted_input),
        user_pubkey: Some(user_pubkey),
        privacy_mode,
        assigned_node: Some(assigned_node.clone()),
        status: RequestStatus::Pending,
        retry_count: 0,
        created_at: Self::current_block(),
    });
    
    Self::deposit_event(Event::BaziRequestSubmitted {
        request_id,
        requester: who,
        privacy_mode,
        assigned_node: Some(assigned_node),
    });
    
    Ok(())
}
```

### Phase 3: OCW è°ƒåº¦ + TEE è®¡ç®—

```rust
/// æœ€å¤§é‡è¯•æ¬¡æ•°
const MAX_RETRY_COUNT: u8 = 3;

fn offchain_worker(block_number: BlockNumberFor<T>) {
    if block_number % T::OcwInterval::get() != Zero::zero() {
        return;
    }
    
    for (request_id, request) in PendingRequests::<T>::iter() {
        // è·³è¿‡å·²å®Œæˆæˆ–å·²è¶…è¿‡é‡è¯•æ¬¡æ•°çš„è¯·æ±‚
        if request.status == RequestStatus::Completed {
            continue;
        }
        
        // æ£€æŸ¥è¶…æ—¶
        if Self::is_request_timeout(&request, block_number) {
            Self::submit_status_update(request_id, RequestStatus::Timeout);
            continue;
        }
        
        // æ£€æŸ¥é‡è¯•æ¬¡æ•°
        if request.retry_count >= MAX_RETRY_COUNT {
            log::error!("Request {} exceeded max retries", request_id);
            Self::submit_status_update(request_id, RequestStatus::Failed);
            continue;
        }
        
        // æ ‡è®°ä¸ºå¤„ç†ä¸­
        if request.status == RequestStatus::Pending {
            Self::submit_status_update(request_id, RequestStatus::Processing);
        }
        
        // æ ¹æ®éšç§æ¨¡å¼å¤„ç†
        let result = match request.privacy_mode {
            PrivacyMode::Public => {
                // OCW ç›´æ¥è®¡ç®—ï¼ˆæ˜æ–‡ï¼‰
                Self::process_public_request(&request)
            },
            _ => {
                // è°ƒç”¨ TEE èŠ‚ç‚¹å¤„ç†ï¼ˆåŠ å¯†ï¼‰
                Self::process_tee_request(&request)
            },
        };
        
        match result {
            Ok(process_result) => {
                Self::submit_result(request_id, process_result);
            },
            Err(e) => {
                log::warn!("Request {} failed (retry {}): {:?}", 
                    request_id, request.retry_count, e);
                // å¢åŠ é‡è¯•è®¡æ•°ï¼Œä¸‹æ¬¡ OCW å‘¨æœŸä¼šé‡è¯•
                Self::submit_retry_increment(request_id);
            }
        }
    }
}

/// æäº¤çŠ¶æ€æ›´æ–°ï¼ˆunsigned transactionï¼‰
fn submit_status_update(request_id: u64, status: RequestStatus) {
    let call = Call::update_request_status { request_id, status };
    let _ = SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into());
}

/// æäº¤é‡è¯•è®¡æ•°å¢åŠ 
fn submit_retry_increment(request_id: u64) {
    let call = Call::increment_retry_count { request_id };
    let _ = SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into());
}

// ========== æ–°å¢ Extrinsic ==========

#[pallet::call_index(10)]
#[pallet::weight(Weight::from_parts(10_000_000, 0))]
pub fn update_request_status(
    origin: OriginFor<T>,
    request_id: u64,
    status: RequestStatus,
) -> DispatchResult {
    ensure_none(origin)?;
    
    PendingRequests::<T>::mutate(request_id, |req| {
        if let Some(r) = req {
            r.status = status;
        }
    });
    
    // å¦‚æœæ˜¯è¶…æ—¶æˆ–å¤±è´¥ï¼Œè§¦å‘äº‹ä»¶é€šçŸ¥ç”¨æˆ·
    if status == RequestStatus::Timeout || status == RequestStatus::Failed {
        if let Some(request) = PendingRequests::<T>::get(request_id) {
            Self::deposit_event(Event::BaziRequestFailed {
                request_id,
                requester: request.requester,
                reason: status,
            });
        }
    }
    
    Ok(())
}

#[pallet::call_index(11)]
#[pallet::weight(Weight::from_parts(10_000_000, 0))]
pub fn increment_retry_count(
    origin: OriginFor<T>,
    request_id: u64,
) -> DispatchResult {
    ensure_none(origin)?;
    
    PendingRequests::<T>::mutate(request_id, |req| {
        if let Some(r) = req {
            r.retry_count = r.retry_count.saturating_add(1);
            r.status = RequestStatus::Pending;  // é‡ç½®ä¸ºå¾…å¤„ç†
        }
    });
    
    Ok(())
}

/// OCW è°ƒç”¨ TEE èŠ‚ç‚¹ HTTP API
fn process_tee_request(request: &PendingBaziRequest<T>) -> Result<ProcessResult, &'static str> {
    let tee_node = TeeNodes::<T>::get(&request.assigned_node.as_ref().unwrap())
        .ok_or("TEE node not found")?;
    
    // æå–åŠ å¯†è¾“å…¥
    let encrypted_input = match &request.input_data {
        InputData::Encrypted(data) => data,
        _ => return Err("Expected encrypted input"),
    };
    
    let user_pubkey = request.user_pubkey.as_ref().ok_or("User pubkey required")?;
    
    // 1. HTTP è°ƒç”¨ TEE Enclaveï¼ˆä¼ é€’ privacy_modeï¼‰
    let tee_response = Self::call_tee_http(
        &tee_node.endpoint,
        encrypted_input,
        user_pubkey,
        request.privacy_mode,  // ä¼ é€’éšç§æ¨¡å¼
    )?;
    
    // OCW åªèƒ½çœ‹åˆ°åŠ å¯†æ•°æ®ï¼Œæ— æ³•è§£å¯†
    // tee_response åŒ…å«:
    // - encrypted_manifest: ç”¨æˆ·å…¬é’¥åŠ å¯†çš„ JSON
    // - sizhu_index: å…¬å¼€çš„å››æŸ±ç´¢å¼•ï¼ˆPrivate æ¨¡å¼ä¸‹ä¸º Noneï¼‰
    // - computation_proof: TEE è®¡ç®—è¯æ˜
    // - enclave_signature: Enclave ç­¾å
    
    // 2. ä¸Šä¼ åŠ å¯† JSON åˆ° IPFS
    let cid = Self::upload_to_ipfs(&tee_response.encrypted_manifest)?;
    
    // 3. è¯·æ±‚ PIN
    Self::request_pin(&cid)?;
    
    Ok(ProcessResult {
        manifest_cid: cid,
        manifest_hash: tee_response.manifest_hash,
        sizhu_index: tee_response.sizhu_index,
        proof: Some(tee_response.computation_proof),
    })
}

fn call_tee_http(
    endpoint: &str,
    encrypted_input: &EncryptedData,
    user_pubkey: &[u8; 32],
    privacy_mode: PrivacyMode,  // ä¼ é€’éšç§æ¨¡å¼ç»™ TEE
) -> Result<TeeComputeResponse, &'static str> {
    let request = http::Request::post(
        &format!("{}/compute/bazi", endpoint),
        serde_json::json!({
            "encrypted_input": {
                "ciphertext": hex::encode(&encrypted_input.ciphertext),
                "nonce": hex::encode(&encrypted_input.nonce),
                "sender_pubkey": hex::encode(&encrypted_input.sender_pubkey),
            },
            "user_pubkey": hex::encode(user_pubkey),
            "privacy_mode": privacy_mode as u8,  // 0=Public, 1=Encrypted, 2=Private
        }).to_string().into_bytes(),
    );
    
    let response = request.send().map_err(|_| "TEE request failed")?;
    let body = response.body().collect::<Vec<u8>>();
    serde_json::from_slice(&body).map_err(|_| "Parse failed")
}
```

### Phase 4: TEE Enclave å†…éƒ¨è®¡ç®—

```rust
// æ­¤ä»£ç è¿è¡Œåœ¨ TEE Enclave å†…éƒ¨ï¼ˆå®‰å…¨éš”ç¦»åŒºï¼‰

fn compute_bazi_in_enclave(
    encrypted_input: &[u8],
    nonce: &[u8],
    sender_pubkey: &[u8; 32],
    user_pubkey: &[u8; 32],  // ç”¨äºåŠ å¯†è¾“å‡º
    privacy_mode: PrivacyMode,  // éšç§æ¨¡å¼ï¼ˆå†³å®šæ˜¯å¦è¿”å› sizhu_indexï¼‰
) -> EnclaveResult {
    // 1. ECDH è§£å¯†è¾“å…¥
    let shared_key = ecdh_derive_key(ENCLAVE_PRIVKEY, sender_pubkey);
    let plaintext = aes_gcm_decrypt(&shared_key, nonce, encrypted_input)?;
    let input: BaziInput = serde_json::from_slice(&plaintext)?;
    
    // 2. å…«å­—è®¡ç®—ï¼ˆæ‰€æœ‰è®¡ç®—åœ¨ Enclave å†…å­˜ä¸­è¿›è¡Œï¼‰
    let sizhu = calculate_sizhu(input.year, input.month, input.day, input.hour);
    let dayun = calculate_dayun(&sizhu, input.gender, input.year);
    let wuxing = calculate_wuxing_strength(&sizhu);
    let xiyong = determine_xiyong_shen(&sizhu, &wuxing);
    
    // 3. ç”Ÿæˆ JSON æ¸…å•
    let manifest = serde_json::json!({
        "version": "1.0",
        "schema": "bazi-manifest-v1",
        "sizhu": sizhu_to_json(&sizhu),
        "dayun": dayun_to_json(&dayun),
        "analysis": { "wuxing_strength": wuxing, "xiyong_shen": xiyong }
    });
    
    // 4. ç”¨ç”¨æˆ·å…¬é’¥åŠ å¯†è¾“å‡º
    let output_key = ecdh_derive_key(ENCLAVE_PRIVKEY, user_pubkey);
    let output_nonce = generate_random_nonce();
    let encrypted_manifest = aes_gcm_encrypt(&output_key, &output_nonce, manifest.to_string().as_bytes());
    
    // 5. è®¡ç®—å“ˆå¸Œ
    let manifest_hash = sha256(manifest.to_string().as_bytes());
    
    // 6. Enclave ç­¾å
    let signature = enclave_sign(&[
        &sizhu.to_index().encode(),
        &manifest_hash,
    ]);
    
    // 7. ç”Ÿæˆè®¡ç®—è¯æ˜
    let proof = ComputationProof {
        mrenclave: MRENCLAVE,
        timestamp: current_time(),
        signature,
    };
    
    EnclaveResult {
        encrypted_manifest: EncryptedManifest {
            algorithm: "AES-256-GCM",
            nonce: output_nonce,
            enclave_pubkey: ENCLAVE_PUBKEY,
            ciphertext: encrypted_manifest,
        },
        // æ ¹æ® privacy_mode å†³å®šæ˜¯å¦è¿”å› sizhu_index
        sizhu_index: match privacy_mode {
            PrivacyMode::Private => None,  // Private æ¨¡å¼ä¸è¿”å›ï¼Œä¿æŠ¤éšç§
            _ => Some(sizhu.to_index()),   // å…¶ä»–æ¨¡å¼è¿”å›ç”¨äºé“¾ä¸Šè®¡ç®—
        },
        gender: match privacy_mode {
            PrivacyMode::Private => None,
            _ => Some(input.gender),
        },
        manifest_hash,
        computation_proof: proof,
    }
}
```

### Phase 5: ç»“æœæäº¤ï¼ˆOCW â†’ é“¾ä¸Šï¼‰

```rust
#[pallet::call_index(1)]
pub fn confirm_bazi_result(
    origin: OriginFor<T>,
    request_id: u64,
    manifest_cid: Vec<u8>,
    manifest_hash: [u8; 32],
    sizhu_index: Option<SiZhuIndex>,
    gender: Option<Gender>,
    computation_proof: Option<ComputationProof>,
    enclave_signature: Option<[u8; 64]>,
) -> DispatchResult {
    // OCW unsigned transaction
    ensure_none(origin)?;
    
    // 1. è·å–å¹¶éªŒè¯è¯·æ±‚
    let request = PendingRequests::<T>::take(request_id)
        .ok_or(Error::<T>::RequestNotFound)?;
    
    // 2. å¦‚æœæ˜¯ TEE ç”Ÿæˆï¼ŒéªŒè¯ç­¾åå’Œè¯æ˜
    if let Some(proof) = &computation_proof {
        Self::verify_enclave_signature(
            &request.assigned_node.unwrap(),
            &sizhu_index,
            &manifest_hash,
            &enclave_signature.unwrap(),
        )?;
        Self::verify_computation_proof(proof)?;
    }
    
    // 3. ç”Ÿæˆå‘½ç›˜ ID
    let chart_id = Self::next_chart_id(&request.requester);
    
    // 4. å­˜å‚¨æœ€ç»ˆæ•°æ®
    let cid_bounded: BoundedVec<u8, ConstU32<64>> = manifest_cid
        .try_into()
        .map_err(|_| Error::<T>::CidTooLong)?;
    
    BaziCharts::<T>::insert(&request.requester, chart_id, BaziOnChain {
        owner: request.requester.clone(),
        privacy_mode: request.privacy_mode,
        sizhu_index,
        gender,
        manifest_cid: cid_bounded,
        manifest_hash,
        generation: match computation_proof {
            Some(proof) => GenerationInfo::Tee {
                node: request.assigned_node.unwrap(),
                proof,
            },
            None => GenerationInfo::Ocw,
        },
        version: 1,
        created_at: Self::current_block(),
        updated_at: Self::current_block(),
    });
    
    // 5. è§¦å‘å®Œæˆäº‹ä»¶
    Self::deposit_event(Event::BaziCreated {
        request_id,
        owner: request.requester,
        chart_id,
        privacy_mode: request.privacy_mode,
    });
    
    Ok(())
}
```

### Phase 6: ç”¨æˆ·è§£å¯†æŸ¥çœ‹ï¼ˆå‰ç«¯ï¼‰

```typescript
async function viewBaziChart(chartId: number) {
  // 1. è·å–é“¾ä¸Šæ•°æ®
  const onChain = await api.query.bazi.baziCharts(account.address, chartId);
  
  // 2. ä» IPFS è·å–åŠ å¯†æ¸…å•
  const response = await fetch(`https://ipfs.io/ipfs/${onChain.manifest_cid}`);
  const encryptedManifest = await response.json();
  
  // 3. å¦‚æœæ˜¯åŠ å¯†æ¨¡å¼ï¼Œè§£å¯†
  if (onChain.privacy_mode !== 'Public') {
    const decrypted = nacl.box.open(
      new Uint8Array(encryptedManifest.ciphertext),
      new Uint8Array(encryptedManifest.nonce),
      new Uint8Array(encryptedManifest.enclave_pubkey),
      userKeyPair.secretKey  // ç”¨æˆ·ç§é’¥
    );
    
    if (!decrypted) {
      throw new Error('Decryption failed - wrong key?');
    }
    
    return JSON.parse(Buffer.from(decrypted).toString());
  }
  
  // å…¬å¼€æ¨¡å¼ç›´æ¥è¿”å›
  return encryptedManifest;
}
```

---

## å‰ç«¯å¯†é’¥ç®¡ç†

ç”¨æˆ·ç§é’¥ç”¨äºè§£å¯† IPFS ä¸Šçš„åŠ å¯†æ¸…å•ï¼Œéœ€è¦å®‰å…¨æŒä¹…åŒ–å­˜å‚¨ã€‚

### å¯†é’¥æ´¾ç”Ÿæ–¹æ¡ˆï¼ˆæ¨èï¼‰

```typescript
import { Keyring } from '@polkadot/keyring';
import { mnemonicToMiniSecret } from '@polkadot/util-crypto';
import nacl from 'tweetnacl';

/**
 * ä» Substrate è´¦æˆ·æ´¾ç”Ÿ ECDH å¯†é’¥å¯¹
 * ä¼˜ç‚¹ï¼šç”¨æˆ·æ— éœ€é¢å¤–è®°å¿†å¯†é’¥ï¼Œä¸è´¦æˆ·ç»‘å®š
 */
async function deriveKeyPairFromAccount(mnemonic: string, accountIndex: number = 0): Promise<nacl.BoxKeyPair> {
  // 1. ä»åŠ©è®°è¯æ´¾ç”Ÿç§å­
  const seed = mnemonicToMiniSecret(mnemonic);
  
  // 2. ä½¿ç”¨æ´¾ç”Ÿè·¯å¾„ç”Ÿæˆå…«å­—ä¸“ç”¨å¯†é’¥
  const derivationPath = `bazi/encryption/${accountIndex}`;
  const derivedSeed = await crypto.subtle.digest(
    'SHA-256',
    new TextEncoder().encode(`${seed.toString()}:${derivationPath}`)
  );
  
  // 3. ç”Ÿæˆ X25519 å¯†é’¥å¯¹
  return nacl.box.keyPair.fromSecretKey(new Uint8Array(derivedSeed));
}

/**
 * è·å–æˆ–åˆ›å»ºç”¨æˆ·å¯†é’¥å¯¹
 */
async function getUserKeyPair(account: InjectedAccountWithMeta): Promise<nacl.BoxKeyPair> {
  const storageKey = `bazi_keypair_${account.address}`;
  
  // 1. å°è¯•ä» localStorage åŠ è½½
  const cached = localStorage.getItem(storageKey);
  if (cached) {
    const { publicKey, secretKey } = JSON.parse(cached);
    return {
      publicKey: new Uint8Array(publicKey),
      secretKey: new Uint8Array(secretKey),
    };
  }
  
  // 2. å¦‚æœç”¨æˆ·ä½¿ç”¨åŠ©è®°è¯ç™»å½•ï¼Œæ´¾ç”Ÿå¯†é’¥
  if (account.meta.source === 'mnemonic') {
    const mnemonic = await promptUserForMnemonic();
    const keyPair = await deriveKeyPairFromAccount(mnemonic);
    
    // ç¼“å­˜åˆ° localStorageï¼ˆå¯é€‰ï¼šåŠ å¯†å­˜å‚¨ï¼‰
    localStorage.setItem(storageKey, JSON.stringify({
      publicKey: Array.from(keyPair.publicKey),
      secretKey: Array.from(keyPair.secretKey),
    }));
    
    return keyPair;
  }
  
  // 3. ç¡¬ä»¶é’±åŒ…ç”¨æˆ·ï¼šç”Ÿæˆç‹¬ç«‹å¯†é’¥å¯¹
  const keyPair = nacl.box.keyPair();
  
  // âš ï¸ è­¦å‘Šç”¨æˆ·å¤‡ä»½å¯†é’¥
  await showBackupKeyDialog(keyPair);
  
  localStorage.setItem(storageKey, JSON.stringify({
    publicKey: Array.from(keyPair.publicKey),
    secretKey: Array.from(keyPair.secretKey),
  }));
  
  return keyPair;
}
```

### å¯†é’¥æ¢å¤æœºåˆ¶

```typescript
/**
 * å¯†é’¥æ¢å¤é€‰é¡¹
 */
enum KeyRecoveryMethod {
  // ä»åŠ©è®°è¯é‡æ–°æ´¾ç”Ÿ
  FromMnemonic = 'mnemonic',
  // ä»å¤‡ä»½æ–‡ä»¶å¯¼å…¥
  FromBackup = 'backup',
  // é‡æ–°ç”Ÿæˆï¼ˆæ—§æ•°æ®å°†æ— æ³•è§£å¯†ï¼‰
  Regenerate = 'regenerate',
}

async function recoverKeyPair(method: KeyRecoveryMethod): Promise<nacl.BoxKeyPair> {
  switch (method) {
    case KeyRecoveryMethod.FromMnemonic:
      const mnemonic = await promptUserForMnemonic();
      return deriveKeyPairFromAccount(mnemonic);
      
    case KeyRecoveryMethod.FromBackup:
      const file = await promptUserForBackupFile();
      const backup = JSON.parse(await file.text());
      return {
        publicKey: new Uint8Array(backup.publicKey),
        secretKey: new Uint8Array(backup.secretKey),
      };
      
    case KeyRecoveryMethod.Regenerate:
      // âš ï¸ è­¦å‘Šï¼šæ—§çš„åŠ å¯†æ•°æ®å°†æ— æ³•è§£å¯†
      if (!await confirmRegenerate()) {
        throw new Error('User cancelled');
      }
      return nacl.box.keyPair();
  }
}
```

### å®‰å…¨å»ºè®®

| åœºæ™¯ | å»ºè®® |
|------|------|
| **åŠ©è®°è¯ç”¨æˆ·** | ä½¿ç”¨æ´¾ç”Ÿå¯†é’¥ï¼Œæ— éœ€é¢å¤–å¤‡ä»½ |
| **ç¡¬ä»¶é’±åŒ…ç”¨æˆ·** | å¿…é¡»å¤‡ä»½å¯†é’¥æ–‡ä»¶æˆ–åŠ©è®°è¯ |
| **å¤šè®¾å¤‡åŒæ­¥** | é€šè¿‡å¤‡ä»½æ–‡ä»¶æˆ–åŠ©è®°è¯æ¢å¤ |
| **å¯†é’¥ä¸¢å¤±** | æ—§æ•°æ®æ— æ³•è§£å¯†ï¼Œéœ€é‡æ–°åˆ›å»ºå‘½ç›˜ |

---

## éšç§é£é™©åˆ†æ

### æ•°æ®æµå…¨é“¾è·¯å®¡è®¡

| é˜¶æ®µ | æ•°æ®çŠ¶æ€ | å¯è§æ–¹ | é£é™©ç­‰çº§ |
|------|----------|--------|----------|
| å‰ç«¯è¾“å…¥ | æ˜æ–‡ | ç”¨æˆ· | - |
| å‰ç«¯åŠ å¯† | å¯†æ–‡ | ç”¨æˆ·ã€é“¾ä¸Šã€OCW | âœ… å®‰å…¨ |
| é“¾ä¸Šå­˜å‚¨ | å¯†æ–‡ | æ‰€æœ‰äºº | âš ï¸ P1 |
| OCW ä¸­ç»§ | å¯†æ–‡ | OCW èŠ‚ç‚¹ | âš ï¸ P2 |
| TEE å†…éƒ¨ | æ˜æ–‡ï¼ˆéš”ç¦»ï¼‰ | TEE Enclave | âœ… å®‰å…¨ |
| IPFS å­˜å‚¨ | å¯†æ–‡ | æ‰€æœ‰äºº | âœ… å®‰å…¨ |
| ç”¨æˆ·è§£å¯† | æ˜æ–‡ | ç”¨æˆ· | - |

### é£é™©ç‚¹è¯¦ç»†åˆ†æ

| é£é™©ID | ä½ç½® | æè¿° | ä¸¥é‡åº¦ | ç¼“è§£æªæ–½ |
|--------|------|------|--------|----------|
| **P1** | é“¾ä¸Š | åŠ å¯†æ•°æ®é•¿æœŸå­˜å‚¨ï¼Œæœªæ¥é‡å­è®¡ç®—å¯èƒ½ç ´è§£ | ä¸­ | ä½¿ç”¨æŠ—é‡å­åŠ å¯†ç®—æ³• |
| **P2** | OCW | èŠ‚ç‚¹è¿è¥è€…è®°å½•å…ƒæ•°æ®ï¼ˆæ—¶é—´ã€åœ°å€ã€å¤§å°ï¼‰ | ä½ | å¤šèŠ‚ç‚¹éšæœºåˆ†é… |
| **P3** | ç½‘ç»œ | OCWâ†”TEE é€šä¿¡è¢«ç›‘å¬ | ä½ | TLS + ç«¯åˆ°ç«¯åŠ å¯† |
| **P4** | TEE | ä¾§ä¿¡é“æ”»å‡» | ä½ | åŠæ—¶æ›´æ–°å¾®ç  |
| **P5** | IPFS | CID ä¸ç”¨æˆ·åœ°å€å…³è” | ä¸­ | ä½¿ç”¨ä¸­ç»§/æ··æ·† |
| **P6** | é“¾ä¸Š | sizhu_index å¯åæ¨å‡ºç”Ÿæ—¶é—´ | **é«˜** | **Private æ¨¡å¼** |

### sizhu_index éšç§é—®é¢˜

```
âš ï¸ æ ¸å¿ƒéšç§é£é™©

é“¾ä¸Šå…¬å¼€ sizhu_index = [year_gz, month_gz, day_gz, hour_gz]

æ”»å‡»è€…å¯æ¨æ–­:
1. year_gz â†’ å¯èƒ½å¹´ä»½ï¼ˆ60å¹´å‘¨æœŸï¼‰
2. month_gz â†’ ç¡®å®šæœˆä»½èŒƒå›´
3. day_gz â†’ ç»“åˆå¹´æœˆç¡®å®šæ—¥æœŸ
4. hour_gz â†’ ç¡®å®š 2 å°æ—¶çª—å£

æ¨æ–­ç²¾åº¦: å·²çŸ¥å¹´é¾„ + sizhu_index â†’ ç²¾ç¡®åˆ° Â±2 å°æ—¶

è§£å†³æ–¹æ¡ˆ: ä½¿ç”¨ Private æ¨¡å¼ï¼ˆä¸å­˜å‚¨ sizhu_indexï¼‰
```

### éšç§ä¿æŠ¤ç­‰çº§

| æ¨¡å¼ | sizhu æ³„éœ² | JSON æ³„éœ² | ç»¼åˆéšç§ |
|------|------------|-----------|----------|
| **Public** | ğŸ”´ æ˜¯ | ğŸ”´ æ˜¯ | â­ 20% |
| **Encrypted** | ğŸ”´ æ˜¯ | âœ… å¦ | â­â­â­ 60% |
| **Private** | âœ… å¦ | âœ… å¦ | â­â­â­â­â­ 95% |

---

## IPFS PIN ç­–ç•¥

### ç‰ˆæœ¬ç®¡ç†

```rust
pub enum PinPolicy {
    /// åª PIN æœ€æ–°ç‰ˆæœ¬
    LatestOnly,
    /// PIN æ‰€æœ‰ç‰ˆæœ¬
    KeepAll,
    /// ä¿ç•™æœ€è¿‘ N ä¸ªç‰ˆæœ¬
    KeepRecent(u32),
}

fn update_manifest_with_pin_policy(
    old_cid: &str,
    new_cid: &str,
    policy: PinPolicy,
) -> Result<(), &'static str> {
    // PIN æ–°ç‰ˆæœ¬
    Self::pin_to_ipfs(new_cid)?;
    
    // æ ¹æ®ç­–ç•¥å¤„ç†æ—§ç‰ˆæœ¬
    match policy {
        PinPolicy::LatestOnly => Self::unpin_from_ipfs(old_cid)?,
        PinPolicy::KeepAll => {},
        PinPolicy::KeepRecent(n) => Self::cleanup_old_versions(n)?,
    }
    
    Ok(())
}
```

### PIN æœåŠ¡é…ç½®

| ç­–ç•¥ | è¯´æ˜ | é€‚ç”¨åœºæ™¯ |
|------|------|----------|
| **æœ¬åœ°èŠ‚ç‚¹** | OCW è°ƒç”¨æœ¬åœ° IPFS | å¼€å‘/æµ‹è¯• |
| **Pinata** | è¿œç¨‹ PIN æœåŠ¡ | ç”Ÿäº§ç¯å¢ƒ |
| **å¤šç½‘å…³å†—ä½™** | åŒæ—¶ PIN å¤šä¸ªæœåŠ¡ | é«˜å¯ç”¨éœ€æ±‚ |

---

## é…ç½®å‚æ•°

```rust
parameter_types! {
    /// è¯·æ±‚è¶…æ—¶ï¼ˆåŒºå—æ•°ï¼Œ~10 åˆ†é’Ÿï¼‰
    pub const RequestTimeout: u32 = 100;
    
    /// OCW å¤„ç†é—´éš”ï¼ˆæ¯ 5 ä¸ªåŒºå—ï¼‰
    pub const OcwInterval: u32 = 5;
    
    /// TEE èŠ‚ç‚¹æœ€å¤§æ•°é‡
    pub const MaxTeeNodes: u32 = 100;
    
    /// é»˜è®¤ PIN ç­–ç•¥
    pub const DefaultPinPolicy: PinPolicy = PinPolicy::KeepRecent(3);
}
```

---

## TEE å®‰å…¨æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TEE ä¿¡ä»»è¾¹ç•Œ                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              å¯ä¿¡åŒºåŸŸ (TCB)                               â”‚    â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚   â”‚            Intel SGX Enclave                    â”‚    â”‚    â”‚
â”‚  â”‚   â”‚  â€¢ CPU ç¡¬ä»¶ä¿æŠ¤                                 â”‚    â”‚    â”‚
â”‚  â”‚   â”‚  â€¢ å†…å­˜åŠ å¯† (MEE)                               â”‚    â”‚    â”‚
â”‚  â”‚   â”‚  â€¢ ä»£ç å®Œæ•´æ€§éªŒè¯ (MRENCLAVE)                   â”‚    â”‚    â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              ä¸å¯ä¿¡åŒºåŸŸ                                  â”‚    â”‚
â”‚  â”‚  â€¢ æ“ä½œç³»ç»Ÿ / OCW èŠ‚ç‚¹                                  â”‚    â”‚
â”‚  â”‚  â€¢ ç½‘ç»œä¼ è¾“ï¼ˆéœ€åŠ å¯†ï¼‰                                   â”‚    â”‚
â”‚  â”‚  â€¢ IPFS å­˜å‚¨ï¼ˆåŠ å¯†å†…å®¹ï¼‰                                â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å‰ç½®æ¡ä»¶

> âš ï¸ **é‡è¦**ï¼šTEE æ–¹æ¡ˆä¾èµ– `pallet-tee-privacy` çš„ IAS ç­¾åéªŒè¯åŠŸèƒ½ã€‚
> å½“å‰è¯¥åŠŸèƒ½è®¡åˆ’åœ¨ Phase 4 å®ç°ï¼ˆå‚è§ C-2 æ¼æ´ï¼‰ã€‚
> åœ¨ IAS éªŒè¯å®ç°å‰ï¼ŒTEE æ–¹æ¡ˆçš„å®‰å…¨æ€§æ— æ³•å®Œå…¨ä¿è¯ã€‚

---

## æ•°æ®æ›´æ–°æœºåˆ¶

### æ›´æ–°æµç¨‹

```rust
#[pallet::call_index(2)]
pub fn update_bazi_manifest(
    origin: OriginFor<T>,
    chart_id: u64,
    new_encrypted_input: EncryptedData,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // 1. éªŒè¯æ‰€æœ‰è€…
    let chart = BaziCharts::<T>::get(&who, chart_id)
        .ok_or(Error::<T>::ChartNotFound)?;
    ensure!(chart.owner == who, Error::<T>::NotOwner);
    
    // 2. åˆ›å»ºæ›´æ–°è¯·æ±‚ï¼ˆèµ°ç›¸åŒçš„ OCW + TEE æµç¨‹ï¼‰
    let request_id = Self::create_update_request(chart_id, new_encrypted_input)?;
    
    Self::deposit_event(Event::BaziUpdateRequested {
        chart_id,
        request_id,
        owner: who,
    });
    
    Ok(())
}
```

### ç‰ˆæœ¬è¿½æº¯

```
æ›´æ–°åçš„é“¾ä¸Šå­˜å‚¨:

Version 1 â†’ Version 2 â†’ Version 3
   â”‚            â”‚            â”‚
   â–¼            â–¼            â–¼
CID: abc...  CID: def...  CID: ghi... (å½“å‰)

é“¾ä¸Šè®°å½•:
- current_cid: ghi...
- version: 3
- previous_cid: def... (å¯é€‰ä¿ç•™)
```

---

## å®ç°è·¯çº¿å›¾

### Phase 1: åŸºç¡€æ¶æ„ (2å‘¨)

1. å®šä¹‰ç»Ÿä¸€çš„ `BaziOnChain` é“¾ä¸Šç»“æ„
2. å®šä¹‰ `PendingBaziRequest` å¾…å¤„ç†ç»“æ„
3. å®šä¹‰ JSON Manifest Schema
4. å®ç° `create_bazi` extrinsicï¼ˆæ”¯æŒéšç§æ¨¡å¼é€‰æ‹©ï¼‰
5. å®ç° `confirm_bazi_result` extrinsic

### Phase 2: OCW å®ç° (2å‘¨)

1. OCW è½®è¯¢å¾…å¤„ç†è¯·æ±‚
2. OCW å¤„ç† Public æ¨¡å¼ï¼ˆç›´æ¥è®¡ç®—ï¼‰
3. OCW è°ƒç”¨ TEE HTTP API
4. IPFS ä¸Šä¼  + PIN æœåŠ¡é›†æˆ
5. è¶…æ—¶/é‡è¯•æœºåˆ¶

### Phase 3: TEE é›†æˆ (3å‘¨)

1. å®ç° IAS ç­¾åéªŒè¯ï¼ˆä¿®å¤ C-2ï¼‰
2. TEE Enclave å…«å­—è®¡ç®—é€»è¾‘
3. Enclave JSON ç”Ÿæˆ + åŠ å¯†
4. è®¡ç®—è¯æ˜ç”Ÿæˆä¸éªŒè¯
5. TEE èŠ‚ç‚¹ HTTP API æœåŠ¡

### Phase 4: å‰ç«¯é›†æˆ (2å‘¨)

1. ECDH å¯†é’¥åå•†
2. åŠ å¯†/è§£å¯† UI
3. éšç§æ¨¡å¼é€‰æ‹©
4. ç«¯åˆ°ç«¯æµ‹è¯•

### Phase 5: ä¼˜åŒ–ä¸æ¸…ç† (1å‘¨)

1. æ€§èƒ½ä¼˜åŒ–
2. æ•°æ®è¿ç§»å·¥å…·
3. æ–‡æ¡£å®Œå–„

---

## æ–¹æ¡ˆé€‰æ‹©å»ºè®®

| åœºæ™¯ | æ¨èæ¨¡å¼ | ç†ç”± |
|------|----------|------|
| **å…¬å¼€å±•ç¤º** | Public | ç®€å•é«˜æ•ˆï¼Œä»»ä½•äººå¯æŸ¥çœ‹ |
| **ä¸ªäººéšç§** | Encrypted | é“¾ä¸Šä¿ç•™ sizhu ç”¨äºè®¡ç®—ï¼ŒJSON åŠ å¯† |
| **æœ€é«˜éšç§** | Private | é“¾ä¸Šä¸å­˜å‚¨ä»»ä½•å¯åæ¨æ•°æ® |
| **å•†ä¸šæœåŠ¡** | Private + TEE | åˆè§„æ€§è¦æ±‚ï¼Œå®Œæ•´å®¡è®¡èƒ½åŠ› |

---

## ä¸ç°æœ‰æ¨¡å—ä¸€è‡´æ€§

| æ¨¡å— | é“¾ä¸Šå­˜å‚¨ | é“¾ä¸‹æ¸…å• | ç”Ÿæˆæ–¹å¼ |
|------|----------|----------|----------|
| Evidence | `evidence_hash` + `manifest_cid` | JSON è¯æ®æ¸…å• | OCW |
| **BaZi** | `sizhu_index?` + `manifest_cid` | JSON å…«å­—æ¸…å• | OCW + TEE |

---

## æ€»ç»“

**OCW + TEE ç»“åˆæ¶æ„**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ ¸å¿ƒè®¾è®¡åŸåˆ™                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. OCW è´Ÿè´£è°ƒåº¦ï¼ŒTEE è´Ÿè´£è®¡ç®—                                  â”‚
â”‚     - OCW: è½®è¯¢ã€ä¸­ç»§ã€IPFSã€æäº¤                              â”‚
â”‚     - TEE: è§£å¯†ã€è®¡ç®—ã€åŠ å¯†ã€ç­¾å                              â”‚
â”‚                                                                 â”‚
â”‚  2. ä¸‰ç§éšç§æ¨¡å¼æ»¡è¶³ä¸åŒéœ€æ±‚                                    â”‚
â”‚     - Public: å…¬å¼€å±•ç¤º                                         â”‚
â”‚     - Encrypted: ä¸ªäººéšç§                                      â”‚
â”‚     - Private: æœ€é«˜éšç§                                        â”‚
â”‚                                                                 â”‚
â”‚  3. ç«¯åˆ°ç«¯åŠ å¯†ä¿æŠ¤ç”¨æˆ·æ•°æ®                                      â”‚
â”‚     - å‰ç«¯åŠ å¯† â†’ TEE è®¡ç®— â†’ ç”¨æˆ·è§£å¯†                           â”‚
â”‚     - OCW å…¨ç¨‹åªæ¥è§¦å¯†æ–‡                                       â”‚
â”‚                                                                 â”‚
â”‚  4. sizhu_index æ˜¯æ ¸å¿ƒéšç§é£é™©ç‚¹                                â”‚
â”‚     - Encrypted æ¨¡å¼ä»æš´éœ²å››æŸ±                                  â”‚
â”‚     - Private æ¨¡å¼å®Œå…¨ä¿æŠ¤                                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å‚è€ƒ

- `pallets/divination/bazi/src/types.rs` - å…«å­—æ•°æ®ç±»å‹å®šä¹‰
- `pallets/divination/tee-privacy/src/lib.rs` - TEE éšç§è®¡ç®—æ¨¡å—
- `pallets/evidence/src/lib.rs` - Evidence æ¸…å•æ¨¡å¼å‚è€ƒ
- IPFS CID v1 è§„èŒƒ: https://docs.ipfs.tech/concepts/content-addressing/
