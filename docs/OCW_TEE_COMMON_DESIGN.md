# OCW + TEE é€šç”¨æ¶æ„è®¾è®¡

> æ–‡æ¡£æ—¥æœŸ: 2026-01-23  
> ç‰ˆæœ¬: 1.0  
> çŠ¶æ€: è®¾è®¡æ–¹æ¡ˆ

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰ **OCW + TEE é€šç”¨æ¶æ„**ï¼Œä¸ºæ‰€æœ‰å åœæ¨¡å—æä¾›ç»Ÿä¸€çš„éšç§è®¡ç®—åŸºç¡€è®¾æ–½ã€‚

### é€‚ç”¨æ¨¡å—

| æ¨¡å— | ä¸­æ–‡å | è®¡ç®—å¤æ‚åº¦ | æ•æ„Ÿæ•°æ® |
|------|--------|------------|----------|
| `bazi` | å…«å­— | ä¸­ | å‡ºç”Ÿæ—¶é—´ |
| `qimen` | å¥‡é—¨éç”² | é«˜ | å é—®äº‹å®œ |
| `meihua` | æ¢…èŠ±æ˜“æ•° | ä½ | èµ·å¦æ•°å­—/æ—¶é—´ |
| `liuyao` | å…­çˆ» | ä¸­ | æ‘‡å¦ç»“æœ |
| `ziwei` | ç´«å¾®æ–—æ•° | é«˜ | å‡ºç”Ÿæ—¶é—´ |
| `daliuren` | å¤§å…­å£¬ | é«˜ | å é—®æ—¶é—´ |
| `xiaoliuren` | å°å…­å£¬ | ä½ | èµ·å¦æ—¶é—´ |
| `tarot` | å¡”ç½— | ä½ | æŠ½ç‰Œç»“æœ |

---

## æ¶æ„åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨å±‚ï¼ˆå„å åœæ¨¡å—ï¼‰                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  BaZi   â”‚ â”‚  Qimen  â”‚ â”‚ MeiHua  â”‚ â”‚ LiuYao  â”‚ â”‚  ZiWei  â”‚  ...      â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜           â”‚
â”‚       â”‚           â”‚           â”‚           â”‚           â”‚                 â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                               â”‚                                          â”‚
â”‚                               â–¼                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      é€šç”¨å±‚ï¼ˆpallet-divination-ocw-teeï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ è¯·æ±‚ç®¡ç†    â”‚  â”‚ OCW è°ƒåº¦    â”‚  â”‚ TEE é€šä¿¡    â”‚  â”‚ IPFS å­˜å‚¨   â”‚    â”‚
â”‚  â”‚ (Pending)   â”‚  â”‚ (Scheduler) â”‚  â”‚ (Client)    â”‚  â”‚ (Uploader)  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ éšç§æ¨¡å¼    â”‚  â”‚ å¯†é’¥ç®¡ç†    â”‚  â”‚ é‡è¯•æœºåˆ¶    â”‚  â”‚ äº‹ä»¶é€šçŸ¥    â”‚    â”‚
â”‚  â”‚ (Privacy)   â”‚  â”‚ (KeyMgmt)   â”‚  â”‚ (Retry)     â”‚  â”‚ (Events)    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                               â”‚                                          â”‚
â”‚                               â–¼                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      åŸºç¡€å±‚ï¼ˆç°æœ‰æ¨¡å—ï¼‰                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ pallet-tee-     â”‚  â”‚ pallet-stardust â”‚  â”‚ pallet-         â”‚         â”‚
â”‚  â”‚ privacy         â”‚  â”‚ -ipfs           â”‚  â”‚ divination-     â”‚         â”‚
â”‚  â”‚ (TEE èŠ‚ç‚¹ç®¡ç†)  â”‚  â”‚ (IPFS é›†æˆ)     â”‚  â”‚ privacy         â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## é€šç”¨æ¨¡å—è®¾è®¡

### æ¨¡å—è·¯å¾„

```
pallets/divination/ocw-tee/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # ä¸»æ¨¡å—
â”‚   â”œâ”€â”€ types.rs         # é€šç”¨ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ traits.rs        # å¯æ‰©å±• trait
â”‚   â”œâ”€â”€ ocw.rs           # OCW è°ƒåº¦é€»è¾‘
â”‚   â”œâ”€â”€ tee_client.rs    # TEE HTTP å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ ipfs.rs          # IPFS ä¸Šä¼ /PIN
â”‚   â”œâ”€â”€ retry.rs         # é‡è¯•æœºåˆ¶
â”‚   â””â”€â”€ tests.rs         # æµ‹è¯•
```

---

## é€šç”¨ç±»å‹å®šä¹‰ (types.rs)

```rust
//! # OCW + TEE é€šç”¨ç±»å‹å®šä¹‰
//!
//! æœ¬æ¨¡å—å®šä¹‰æ‰€æœ‰å åœæ¨¡å—å…±äº«çš„ç±»å‹ã€‚

use codec::{Decode, Encode, MaxEncodedLen};
use frame_support::BoundedVec;
use frame_support::traits::ConstU32;
use scale_info::TypeInfo;
use sp_std::prelude::*;

// ==================== éšç§æ¨¡å¼ ====================

/// éšç§æ¨¡å¼ï¼ˆæ‰€æœ‰å åœæ¨¡å—é€šç”¨ï¼‰
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum PrivacyMode {
    /// å…¬å¼€æ¨¡å¼ï¼šé“¾ä¸Šå­˜å‚¨ç´¢å¼•ï¼ŒIPFS æ˜æ–‡
    #[default]
    Public = 0,
    /// åŠ å¯†æ¨¡å¼ï¼šé“¾ä¸Šå­˜å‚¨ç´¢å¼•ï¼ŒIPFS åŠ å¯†
    Encrypted = 1,
    /// ç§å¯†æ¨¡å¼ï¼šé“¾ä¸Šä¸å­˜å‚¨ç´¢å¼•ï¼ŒIPFS åŠ å¯†
    Private = 2,
}

impl PrivacyMode {
    pub fn name(&self) -> &'static str {
        match self {
            Self::Public => "public",
            Self::Encrypted => "encrypted",
            Self::Private => "private",
        }
    }
    
    pub fn requires_tee(&self) -> bool {
        !matches!(self, Self::Public)
    }
}

// ==================== è¯·æ±‚çŠ¶æ€ ====================

/// è¯·æ±‚çŠ¶æ€ï¼ˆæ‰€æœ‰å åœæ¨¡å—é€šç”¨ï¼‰
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum RequestStatus {
    /// å¾…å¤„ç†
    #[default]
    Pending = 0,
    /// å¤„ç†ä¸­
    Processing = 1,
    /// å·²å®Œæˆ
    Completed = 2,
    /// å¤±è´¥ï¼ˆå¯é‡è¯•ï¼‰
    Failed = 3,
    /// è¶…æ—¶
    Timeout = 4,
}

// ==================== åŠ å¯†æ•°æ® ====================

/// åŠ å¯†æ•°æ®ï¼ˆæ‰€æœ‰å åœæ¨¡å—é€šç”¨ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(MaxLen))]
pub struct EncryptedData<MaxLen: frame_support::traits::Get<u32>> {
    /// å¯†æ–‡
    pub ciphertext: BoundedVec<u8, MaxLen>,
    /// éšæœºæ•°
    pub nonce: [u8; 24],
    /// å‘é€æ–¹å…¬é’¥
    pub sender_pubkey: [u8; 32],
}

/// é»˜è®¤åŠ å¯†æ•°æ®é•¿åº¦ï¼ˆ256 å­—èŠ‚ï¼Œé€‚ç”¨äºå¤§éƒ¨åˆ†æ¨¡å—ï¼‰
pub type DefaultEncryptedData = EncryptedData<ConstU32<256>>;

/// å¤§å‹åŠ å¯†æ•°æ®é•¿åº¦ï¼ˆ512 å­—èŠ‚ï¼Œé€‚ç”¨äºå¥‡é—¨ç­‰å¤æ‚è¾“å…¥ï¼‰
pub type LargeEncryptedData = EncryptedData<ConstU32<512>>;

// ==================== ç”Ÿæˆä¿¡æ¯ ====================

/// ç”Ÿæˆä¿¡æ¯ï¼ˆæ‰€æœ‰å åœæ¨¡å—é€šç”¨ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum GenerationInfo<AccountId: Clone + Encode + Decode + TypeInfo + MaxEncodedLen> {
    /// OCW ç”Ÿæˆï¼ˆå…¬å¼€æ¨¡å¼ï¼‰
    Ocw,
    /// TEE ç”Ÿæˆï¼ˆåŠ å¯†/ç§å¯†æ¨¡å¼ï¼‰
    Tee {
        /// TEE èŠ‚ç‚¹
        node: AccountId,
        /// è®¡ç®—è¯æ˜
        proof: ComputationProof,
    },
}

/// è®¡ç®—è¯æ˜
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub struct ComputationProof {
    /// MRENCLAVEï¼ˆEnclave ä»£ç å“ˆå¸Œï¼‰
    pub mrenclave: [u8; 32],
    /// è®¡ç®—æ—¶é—´æˆ³
    pub timestamp: u64,
    /// Enclave ç­¾å
    pub signature: [u8; 64],
}

// ==================== å åœç±»å‹ ====================

/// å åœç±»å‹æšä¸¾ï¼ˆç”¨äº TEE è·¯ç”±ï¼‰
#[derive(Clone, Copy, Debug, PartialEq, Eq, Encode, Decode, TypeInfo, MaxEncodedLen)]
pub enum DivinationType {
    /// å…«å­—
    BaZi = 0,
    /// å¥‡é—¨éç”²
    QiMen = 1,
    /// æ¢…èŠ±æ˜“æ•°
    MeiHua = 2,
    /// å…­çˆ»
    LiuYao = 3,
    /// ç´«å¾®æ–—æ•°
    ZiWei = 4,
    /// å¤§å…­å£¬
    DaLiuRen = 5,
    /// å°å…­å£¬
    XiaoLiuRen = 6,
    /// å¡”ç½—
    Tarot = 7,
}

impl DivinationType {
    /// è·å– TEE HTTP ç«¯ç‚¹è·¯å¾„
    pub fn tee_endpoint(&self) -> &'static str {
        match self {
            Self::BaZi => "/compute/bazi",
            Self::QiMen => "/compute/qimen",
            Self::MeiHua => "/compute/meihua",
            Self::LiuYao => "/compute/liuyao",
            Self::ZiWei => "/compute/ziwei",
            Self::DaLiuRen => "/compute/daliuren",
            Self::XiaoLiuRen => "/compute/xiaoliuren",
            Self::Tarot => "/compute/tarot",
        }
    }
    
    /// è·å–æ¨èè¶…æ—¶æ—¶é—´ï¼ˆåŒºå—æ•°ï¼‰
    pub fn recommended_timeout(&self) -> u32 {
        match self {
            Self::BaZi => 100,       // ~10 åˆ†é’Ÿ
            Self::QiMen => 150,      // ~15 åˆ†é’Ÿï¼ˆè®¡ç®—å¤æ‚ï¼‰
            Self::MeiHua => 80,      // ~8 åˆ†é’Ÿ
            Self::LiuYao => 100,     // ~10 åˆ†é’Ÿ
            Self::ZiWei => 150,      // ~15 åˆ†é’Ÿï¼ˆè®¡ç®—å¤æ‚ï¼‰
            Self::DaLiuRen => 150,   // ~15 åˆ†é’Ÿï¼ˆè®¡ç®—å¤æ‚ï¼‰
            Self::XiaoLiuRen => 60,  // ~6 åˆ†é’Ÿï¼ˆç®€å•ï¼‰
            Self::Tarot => 60,       // ~6 åˆ†é’Ÿï¼ˆç®€å•ï¼‰
        }
    }
}

// ==================== é€šç”¨é“¾ä¸Šå­˜å‚¨ ====================

/// é€šç”¨é“¾ä¸Šå­˜å‚¨ç»“æ„ï¼ˆæ¨¡æ¿ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(Index))]
pub struct DivinationOnChain<AccountId, BlockNumber, Index>
where
    AccountId: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
    BlockNumber: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
    Index: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
{
    /// æ‰€æœ‰è€…
    pub owner: AccountId,
    
    /// éšç§æ¨¡å¼
    pub privacy_mode: PrivacyMode,
    
    /// å åœç±»å‹ç‰¹å®šç´¢å¼•ï¼ˆPrivate æ¨¡å¼ä¸‹ä¸º Noneï¼‰
    /// ä¾‹å¦‚ï¼šBaZi çš„ SiZhuIndexï¼ŒQiMen çš„ ChartIndex
    pub type_index: Option<Index>,
    
    /// JSON æ¸…å• CIDï¼ˆIPFSï¼‰
    pub manifest_cid: BoundedVec<u8, ConstU32<64>>,
    
    /// æ¸…å•å“ˆå¸Œï¼ˆç”¨äºéªŒè¯å®Œæ•´æ€§ï¼‰
    pub manifest_hash: [u8; 32],
    
    /// ç”Ÿæˆæ–¹å¼
    pub generation: GenerationInfo<AccountId>,
    
    /// ç‰ˆæœ¬å·
    pub version: u32,
    
    /// åˆ›å»ºåŒºå—
    pub created_at: BlockNumber,
    
    /// æ›´æ–°åŒºå—
    pub updated_at: BlockNumber,
}

// ==================== é€šç”¨å¾…å¤„ç†è¯·æ±‚ ====================

/// é€šç”¨å¾…å¤„ç†è¯·æ±‚ç»“æ„ï¼ˆæ¨¡æ¿ï¼‰
#[derive(Clone, Debug, Encode, Decode, TypeInfo, MaxEncodedLen)]
#[scale_info(skip_type_params(InputData))]
pub struct PendingRequest<AccountId, BlockNumber, InputData>
where
    AccountId: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
    BlockNumber: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
    InputData: Clone + Encode + Decode + TypeInfo + MaxEncodedLen,
{
    /// è¯·æ±‚è€…
    pub requester: AccountId,
    
    /// å åœç±»å‹
    pub divination_type: DivinationType,
    
    /// è¾“å…¥æ•°æ®ï¼ˆæ˜æ–‡æˆ–å¯†æ–‡ï¼‰
    pub input_data: InputData,
    
    /// ç”¨æˆ·å…¬é’¥ï¼ˆç”¨äºåŠ å¯†è¿”å›ç»“æœï¼‰
    pub user_pubkey: Option<[u8; 32]>,
    
    /// éšç§æ¨¡å¼
    pub privacy_mode: PrivacyMode,
    
    /// åˆ†é…çš„ TEE èŠ‚ç‚¹
    pub assigned_node: Option<AccountId>,
    
    /// è¯·æ±‚çŠ¶æ€
    pub status: RequestStatus,
    
    /// é‡è¯•æ¬¡æ•°
    pub retry_count: u8,
    
    /// åˆ›å»ºåŒºå—
    pub created_at: BlockNumber,
}

// ==================== TEE å“åº” ====================

/// TEE è®¡ç®—å“åº”ï¼ˆé€šç”¨ï¼‰
#[derive(Clone, Debug, Encode, Decode)]
pub struct TeeComputeResponse {
    /// åŠ å¯†çš„ JSON æ¸…å•
    pub encrypted_manifest: Vec<u8>,
    /// æ¸…å•å“ˆå¸Œ
    pub manifest_hash: [u8; 32],
    /// ç±»å‹ç‰¹å®šç´¢å¼•ï¼ˆç¼–ç åï¼‰
    pub type_index: Option<Vec<u8>>,
    /// è®¡ç®—è¯æ˜
    pub computation_proof: ComputationProof,
    /// Enclave ç­¾å
    pub enclave_signature: [u8; 64],
}
```

---

## é€šç”¨ Trait å®šä¹‰ (traits.rs)

```rust
//! # OCW + TEE é€šç”¨ Trait å®šä¹‰
//!
//! å®šä¹‰å„å åœæ¨¡å—éœ€è¦å®ç°çš„ traitã€‚

use crate::types::*;
use frame_support::dispatch::DispatchResult;
use sp_std::prelude::*;

/// å åœè®¡ç®— Trait
///
/// å„å åœæ¨¡å—éœ€è¦å®ç°æ­¤ trait æ¥å®šä¹‰è‡ªå·±çš„è®¡ç®—é€»è¾‘ã€‚
pub trait DivinationCompute {
    /// è¾“å…¥ç±»å‹ï¼ˆæ˜æ–‡ï¼‰
    type PlainInput: Clone + Encode + Decode + TypeInfo + MaxEncodedLen;
    
    /// ç´¢å¼•ç±»å‹ï¼ˆé“¾ä¸Šå­˜å‚¨çš„æœ€å°åŒ–æ•°æ®ï¼‰
    type Index: Clone + Encode + Decode + TypeInfo + MaxEncodedLen;
    
    /// è®¡ç®—ç»“æœç±»å‹
    type Result: Clone + Encode + Decode;
    
    /// å åœç±»å‹
    fn divination_type() -> DivinationType;
    
    /// æ‰§è¡Œè®¡ç®—ï¼ˆPublic æ¨¡å¼ä¸‹ OCW ç›´æ¥è°ƒç”¨ï¼‰
    fn compute(input: &Self::PlainInput) -> Result<Self::Result, &'static str>;
    
    /// ä»è®¡ç®—ç»“æœæå–ç´¢å¼•
    fn extract_index(result: &Self::Result, privacy_mode: PrivacyMode) -> Option<Self::Index>;
    
    /// ç”Ÿæˆ JSON æ¸…å•
    fn generate_manifest(
        input: &Self::PlainInput,
        result: &Self::Result,
        privacy_mode: PrivacyMode,
    ) -> Result<Vec<u8>, &'static str>;
}

/// OCW å¤„ç†å™¨ Trait
///
/// é€šç”¨ OCW å¤„ç†é€»è¾‘ï¼Œå„æ¨¡å—å¯å¤ç”¨ã€‚
pub trait OcwProcessor<T: frame_system::Config> {
    /// å¤„ç†å¾…å¤„ç†è¯·æ±‚
    fn process_pending_requests(block_number: T::BlockNumber);
    
    /// å¤„ç† Public æ¨¡å¼è¯·æ±‚
    fn process_public_request<D: DivinationCompute>(
        request_id: u64,
        input: &D::PlainInput,
    ) -> Result<ProcessResult, &'static str>;
    
    /// å¤„ç† TEE æ¨¡å¼è¯·æ±‚
    fn process_tee_request(
        request_id: u64,
        divination_type: DivinationType,
        encrypted_input: &EncryptedData<ConstU32<512>>,
        user_pubkey: &[u8; 32],
        privacy_mode: PrivacyMode,
    ) -> Result<ProcessResult, &'static str>;
}

/// å¤„ç†ç»“æœ
#[derive(Clone, Debug)]
pub struct ProcessResult {
    pub manifest_cid: Vec<u8>,
    pub manifest_hash: [u8; 32],
    pub type_index: Option<Vec<u8>>,
    pub proof: Option<ComputationProof>,
}

/// TEE å®¢æˆ·ç«¯ Trait
pub trait TeeClient {
    /// è°ƒç”¨ TEE èŠ‚ç‚¹
    fn call_tee(
        endpoint: &str,
        divination_type: DivinationType,
        encrypted_input: &[u8],
        user_pubkey: &[u8; 32],
        privacy_mode: PrivacyMode,
    ) -> Result<TeeComputeResponse, &'static str>;
}

/// IPFS å®¢æˆ·ç«¯ Trait
pub trait IpfsClient {
    /// ä¸Šä¼ æ•°æ®åˆ° IPFS
    fn upload(data: &[u8]) -> Result<Vec<u8>, &'static str>;
    
    /// è¯·æ±‚ PIN
    fn pin(cid: &[u8]) -> Result<(), &'static str>;
    
    /// å–æ¶ˆ PIN
    fn unpin(cid: &[u8]) -> Result<(), &'static str>;
}
```

---

## OCW è°ƒåº¦é€»è¾‘ (ocw.rs)

```rust
//! # OCW é€šç”¨è°ƒåº¦é€»è¾‘

use crate::traits::*;
use crate::types::*;
use frame_support::traits::Get;
use sp_runtime::offchain::http;

/// æœ€å¤§é‡è¯•æ¬¡æ•°
pub const MAX_RETRY_COUNT: u8 = 3;

/// é€šç”¨ OCW å¤„ç†å™¨å®ç°
pub struct GenericOcwProcessor<T: Config>(sp_std::marker::PhantomData<T>);

impl<T: Config> GenericOcwProcessor<T> {
    /// ä¸»å¤„ç†å¾ªç¯
    pub fn offchain_worker(block_number: T::BlockNumber) {
        // æ£€æŸ¥å¤„ç†é—´éš”
        if block_number % T::OcwInterval::get() != Zero::zero() {
            return;
        }
        
        // éå†æ‰€æœ‰å¾…å¤„ç†è¯·æ±‚
        for (request_id, request) in PendingRequests::<T>::iter() {
            Self::process_single_request(request_id, request, block_number);
        }
    }
    
    /// å¤„ç†å•ä¸ªè¯·æ±‚
    fn process_single_request(
        request_id: u64,
        request: PendingRequest<T::AccountId, T::BlockNumber, Vec<u8>>,
        block_number: T::BlockNumber,
    ) {
        // è·³è¿‡å·²å®Œæˆ
        if request.status == RequestStatus::Completed {
            return;
        }
        
        // æ£€æŸ¥è¶…æ—¶
        let timeout = request.divination_type.recommended_timeout();
        if Self::is_timeout(&request, block_number, timeout) {
            Self::submit_status_update(request_id, RequestStatus::Timeout);
            return;
        }
        
        // æ£€æŸ¥é‡è¯•æ¬¡æ•°
        if request.retry_count >= MAX_RETRY_COUNT {
            Self::submit_status_update(request_id, RequestStatus::Failed);
            return;
        }
        
        // æ ‡è®°å¤„ç†ä¸­
        if request.status == RequestStatus::Pending {
            Self::submit_status_update(request_id, RequestStatus::Processing);
        }
        
        // æ ¹æ®éšç§æ¨¡å¼å¤„ç†
        let result = if request.privacy_mode == PrivacyMode::Public {
            Self::process_public(request_id, &request)
        } else {
            Self::process_tee(request_id, &request)
        };
        
        match result {
            Ok(process_result) => {
                Self::submit_result(request_id, process_result);
            },
            Err(e) => {
                log::warn!("Request {} failed (retry {}): {:?}", 
                    request_id, request.retry_count, e);
                Self::submit_retry_increment(request_id);
            }
        }
    }
    
    /// å¤„ç† TEE è¯·æ±‚ï¼ˆé€šç”¨ï¼‰
    fn process_tee(
        request_id: u64,
        request: &PendingRequest<T::AccountId, T::BlockNumber, Vec<u8>>,
    ) -> Result<ProcessResult, &'static str> {
        let tee_node = TeeNodes::<T>::get(&request.assigned_node.as_ref().unwrap())
            .ok_or("TEE node not found")?;
        
        let user_pubkey = request.user_pubkey.as_ref().ok_or("User pubkey required")?;
        
        // æ„å»º HTTP è¯·æ±‚
        let endpoint = format!(
            "{}{}",
            tee_node.endpoint,
            request.divination_type.tee_endpoint()
        );
        
        let body = serde_json::json!({
            "encrypted_input": hex::encode(&request.input_data),
            "user_pubkey": hex::encode(user_pubkey),
            "privacy_mode": request.privacy_mode as u8,
            "divination_type": request.divination_type as u8,
        });
        
        // å‘é€è¯·æ±‚
        let http_request = http::Request::post(&endpoint, body.to_string().into_bytes());
        let response = http_request.send().map_err(|_| "TEE request failed")?;
        let response_body = response.body().collect::<Vec<u8>>();
        
        let tee_response: TeeComputeResponse = 
            serde_json::from_slice(&response_body).map_err(|_| "Parse failed")?;
        
        // ä¸Šä¼ åˆ° IPFS
        let cid = T::IpfsClient::upload(&tee_response.encrypted_manifest)?;
        T::IpfsClient::pin(&cid)?;
        
        Ok(ProcessResult {
            manifest_cid: cid,
            manifest_hash: tee_response.manifest_hash,
            type_index: tee_response.type_index,
            proof: Some(tee_response.computation_proof),
        })
    }
}
```

---

## å„æ¨¡å—é›†æˆç¤ºä¾‹

### BaZi æ¨¡å—é›†æˆ

```rust
// pallets/divination/bazi/src/lib.rs

use pallet_divination_ocw_tee::{
    traits::{DivinationCompute, ProcessResult},
    types::{DivinationType, PrivacyMode, EncryptedData, GenerationInfo},
};

/// å…«å­—è®¡ç®—å®ç°
impl DivinationCompute for Pallet<T> {
    type PlainInput = BaziInputPlain;
    type Index = SiZhuIndex;
    type Result = BaziChart;
    
    fn divination_type() -> DivinationType {
        DivinationType::BaZi
    }
    
    fn compute(input: &Self::PlainInput) -> Result<Self::Result, &'static str> {
        // è°ƒç”¨ç°æœ‰çš„å…«å­—è®¡ç®—é€»è¾‘
        let sizhu = calculate_sizhu(input.year, input.month, input.day, input.hour);
        let dayun = calculate_dayun(&sizhu, input.gender, input.year);
        let wuxing = calculate_wuxing_strength(&sizhu);
        
        Ok(BaziChart { sizhu, dayun, wuxing, ... })
    }
    
    fn extract_index(result: &Self::Result, privacy_mode: PrivacyMode) -> Option<Self::Index> {
        match privacy_mode {
            PrivacyMode::Private => None,
            _ => Some(result.sizhu.to_index()),
        }
    }
    
    fn generate_manifest(
        input: &Self::PlainInput,
        result: &Self::Result,
        privacy_mode: PrivacyMode,
    ) -> Result<Vec<u8>, &'static str> {
        let manifest = serde_json::json!({
            "version": "1.0",
            "schema": "bazi-manifest-v1",
            "sizhu": sizhu_to_json(&result.sizhu),
            "dayun": dayun_to_json(&result.dayun),
            // ...
        });
        
        Ok(manifest.to_string().into_bytes())
    }
}

// Extrinsic ç®€åŒ–
#[pallet::call_index(0)]
pub fn create_bazi_public(
    origin: OriginFor<T>,
    year: u16, month: u8, day: u8, hour: u8,
    gender: Gender,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    // ä½¿ç”¨é€šç”¨æ¨¡å—åˆ›å»ºè¯·æ±‚
    pallet_divination_ocw_tee::Pallet::<T>::create_request(
        who,
        DivinationType::BaZi,
        InputData::Plaintext(BaziInputPlain { year, month, day, hour, gender, longitude: None }),
        None,  // user_pubkey
        PrivacyMode::Public,
    )
}

#[pallet::call_index(1)]
pub fn create_bazi(
    origin: OriginFor<T>,
    encrypted_input: EncryptedData<ConstU32<256>>,
    user_pubkey: [u8; 32],
    privacy_mode: PrivacyMode,
) -> DispatchResult {
    let who = ensure_signed(origin)?;
    
    ensure!(privacy_mode != PrivacyMode::Public, Error::<T>::UsePublicExtrinsic);
    
    pallet_divination_ocw_tee::Pallet::<T>::create_request(
        who,
        DivinationType::BaZi,
        InputData::Encrypted(encrypted_input),
        Some(user_pubkey),
        privacy_mode,
    )
}
```

### QiMen æ¨¡å—é›†æˆ

```rust
// pallets/divination/qimen/src/lib.rs

impl DivinationCompute for Pallet<T> {
    type PlainInput = QimenInputPlain;
    type Index = QimenChartIndex;
    type Result = QimenChart;
    
    fn divination_type() -> DivinationType {
        DivinationType::QiMen
    }
    
    fn compute(input: &Self::PlainInput) -> Result<Self::Result, &'static str> {
        // è°ƒç”¨ç°æœ‰çš„å¥‡é—¨æ’ç›˜é€»è¾‘
        let ganzhi = calculate_ganzhi_from_timestamp(input.timestamp);
        let palaces = arrange_palaces(...);
        
        Ok(QimenChart { ganzhi, palaces, ... })
    }
    
    fn extract_index(result: &Self::Result, privacy_mode: PrivacyMode) -> Option<Self::Index> {
        match privacy_mode {
            PrivacyMode::Private => None,
            _ => Some(QimenChartIndex {
                dun_type: result.dun_type,
                ju_number: result.ju_number,
                // ...
            }),
        }
    }
    
    // ...
}
```

---

## å‰ç«¯é€šç”¨ SDK

```typescript
// @stardust/divination-sdk

import nacl from 'tweetnacl';

/**
 * é€šç”¨å åœå®¢æˆ·ç«¯
 */
export class DivinationClient {
  private api: ApiPromise;
  private keyPair: nacl.BoxKeyPair;
  
  constructor(api: ApiPromise, keyPair: nacl.BoxKeyPair) {
    this.api = api;
    this.keyPair = keyPair;
  }
  
  /**
   * åˆ›å»ºå åœè¯·æ±‚ï¼ˆé€šç”¨ï¼‰
   */
  async create<T>(
    divinationType: DivinationType,
    input: T,
    privacyMode: PrivacyMode,
  ): Promise<string> {
    if (privacyMode === PrivacyMode.Public) {
      return this.createPublic(divinationType, input);
    } else {
      return this.createPrivate(divinationType, input, privacyMode);
    }
  }
  
  /**
   * åˆ›å»ºå…¬å¼€è¯·æ±‚
   */
  private async createPublic<T>(
    divinationType: DivinationType,
    input: T,
  ): Promise<string> {
    const extrinsic = this.getPublicExtrinsic(divinationType, input);
    return this.signAndSend(extrinsic);
  }
  
  /**
   * åˆ›å»ºåŠ å¯†è¯·æ±‚
   */
  private async createPrivate<T>(
    divinationType: DivinationType,
    input: T,
    privacyMode: PrivacyMode,
  ): Promise<string> {
    // 1. è·å– TEE å…¬é’¥
    const enclavePubkey = await this.getTeePublicKey();
    
    // 2. åŠ å¯†è¾“å…¥
    const plaintext = JSON.stringify(input);
    const nonce = nacl.randomBytes(24);
    const encrypted = nacl.box(
      new TextEncoder().encode(plaintext),
      nonce,
      enclavePubkey,
      this.keyPair.secretKey
    );
    
    // 3. æ„å»ºåŠ å¯†æ•°æ®
    const encryptedData = {
      ciphertext: Array.from(encrypted),
      nonce: Array.from(nonce),
      sender_pubkey: Array.from(this.keyPair.publicKey),
    };
    
    // 4. æäº¤
    const extrinsic = this.getPrivateExtrinsic(
      divinationType,
      encryptedData,
      Array.from(this.keyPair.publicKey),
      privacyMode,
    );
    
    return this.signAndSend(extrinsic);
  }
  
  /**
   * æŸ¥çœ‹å åœç»“æœï¼ˆé€šç”¨ï¼‰
   */
  async view(
    divinationType: DivinationType,
    chartId: number,
  ): Promise<any> {
    // 1. è·å–é“¾ä¸Šæ•°æ®
    const onChain = await this.getOnChainData(divinationType, chartId);
    
    // 2. ä» IPFS è·å–æ¸…å•
    const manifest = await this.fetchFromIpfs(onChain.manifest_cid);
    
    // 3. å¦‚æœåŠ å¯†ï¼Œè§£å¯†
    if (onChain.privacy_mode !== PrivacyMode.Public) {
      return this.decryptManifest(manifest);
    }
    
    return manifest;
  }
  
  /**
   * è§£å¯†æ¸…å•
   */
  private decryptManifest(encryptedManifest: any): any {
    const decrypted = nacl.box.open(
      new Uint8Array(encryptedManifest.ciphertext),
      new Uint8Array(encryptedManifest.nonce),
      new Uint8Array(encryptedManifest.enclave_pubkey),
      this.keyPair.secretKey
    );
    
    if (!decrypted) {
      throw new Error('Decryption failed');
    }
    
    return JSON.parse(new TextDecoder().decode(decrypted));
  }
  
  // ... è¾…åŠ©æ–¹æ³•
}

// ========== ç±»å‹ç‰¹å®šå®¢æˆ·ç«¯ ==========

/**
 * å…«å­—å®¢æˆ·ç«¯
 */
export class BaziClient extends DivinationClient {
  async createBazi(input: BaziInput, privacyMode: PrivacyMode) {
    return this.create(DivinationType.BaZi, input, privacyMode);
  }
  
  async viewBazi(chartId: number) {
    return this.view(DivinationType.BaZi, chartId);
  }
}

/**
 * å¥‡é—¨å®¢æˆ·ç«¯
 */
export class QimenClient extends DivinationClient {
  async createQimen(input: QimenInput, privacyMode: PrivacyMode) {
    return this.create(DivinationType.QiMen, input, privacyMode);
  }
  
  async viewQimen(chartId: number) {
    return this.view(DivinationType.QiMen, chartId);
  }
}

// ... å…¶ä»–æ¨¡å—å®¢æˆ·ç«¯
```

---

## é…ç½®å‚æ•°

```rust
// runtime/src/lib.rs

parameter_types! {
    /// OCW å¤„ç†é—´éš”ï¼ˆæ¯ 5 ä¸ªåŒºå—ï¼‰
    pub const OcwInterval: u32 = 5;
    
    /// æœ€å¤§é‡è¯•æ¬¡æ•°
    pub const MaxRetryCount: u8 = 3;
    
    /// TEE èŠ‚ç‚¹æœ€å¤§æ•°é‡
    pub const MaxTeeNodes: u32 = 100;
    
    /// é»˜è®¤ PIN ç­–ç•¥
    pub const DefaultPinPolicy: PinPolicy = PinPolicy::KeepRecent(3);
}

impl pallet_divination_ocw_tee::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OcwInterval = OcwInterval;
    type MaxRetryCount = MaxRetryCount;
    type TeePrivacy = TeePrivacy;
    type IpfsClient = StardustIpfs;
}
```

---

## å®ç°è·¯çº¿å›¾

### Phase 1: é€šç”¨æ¨¡å—åŸºç¡€ (2å‘¨)

1. åˆ›å»º `pallet-divination-ocw-tee` æ¨¡å—
2. å®ç°é€šç”¨ç±»å‹å®šä¹‰
3. å®ç°é€šç”¨ trait
4. å®ç° OCW è°ƒåº¦é€»è¾‘
5. å®ç° TEE å®¢æˆ·ç«¯
6. å®ç° IPFS å®¢æˆ·ç«¯

### Phase 2: å…«å­—æ¨¡å—è¿ç§» (1å‘¨)

1. å…«å­—æ¨¡å—å®ç° `DivinationCompute` trait
2. è¿ç§»ç°æœ‰ extrinsic
3. æµ‹è¯•éªŒè¯

### Phase 3: å¥‡é—¨æ¨¡å—è¿ç§» (1å‘¨)

1. å¥‡é—¨æ¨¡å—å®ç° `DivinationCompute` trait
2. è¿ç§»ç°æœ‰ extrinsic
3. æµ‹è¯•éªŒè¯

### Phase 4: å…¶ä»–æ¨¡å—è¿ç§» (3å‘¨)

1. æ¢…èŠ±æ˜“æ•°
2. å…­çˆ»
3. ç´«å¾®æ–—æ•°
4. å¤§å…­å£¬
5. å°å…­å£¬
6. å¡”ç½—

### Phase 5: å‰ç«¯ SDK (2å‘¨)

1. é€šç”¨ DivinationClient
2. å„æ¨¡å—ç‰¹å®šå®¢æˆ·ç«¯
3. æ–‡æ¡£å’Œç¤ºä¾‹

---

## æ€»ç»“

**é€šç”¨ OCW + TEE æ¶æ„ä¼˜åŠ¿**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä»£ç å¤ç”¨                                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. é€šç”¨ç±»å‹ï¼šPrivacyMode, RequestStatus, EncryptedData        â”‚
â”‚     - æ‰€æœ‰æ¨¡å—å…±äº«ï¼Œæ— éœ€é‡å¤å®šä¹‰                                â”‚
â”‚                                                                 â”‚
â”‚  2. é€šç”¨é€»è¾‘ï¼šOCW è°ƒåº¦ã€TEE é€šä¿¡ã€IPFS ä¸Šä¼                      â”‚
â”‚     - ä¸€æ¬¡å®ç°ï¼Œå¤šå¤„å¤ç”¨                                        â”‚
â”‚                                                                 â”‚
â”‚  3. é€šç”¨ Traitï¼šDivinationCompute                               â”‚
â”‚     - å„æ¨¡å—åªéœ€å®ç°è®¡ç®—é€»è¾‘                                    â”‚
â”‚     - æ¡†æ¶å¤„ç†è¯·æ±‚ç®¡ç†ã€é‡è¯•ã€è¶…æ—¶                              â”‚
â”‚                                                                 â”‚
â”‚  4. å‰ç«¯ SDKï¼šç»Ÿä¸€ API                                          â”‚
â”‚     - create(type, input, privacy)                             â”‚
â”‚     - view(type, chartId)                                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä»£ç é‡å¯¹æ¯”**ï¼š

| æ¨¡å— | æ— é€šç”¨æ¶æ„ | æœ‰é€šç”¨æ¶æ„ | èŠ‚çœ |
|------|------------|------------|------|
| å…«å­— | ~1000 è¡Œ | ~300 è¡Œ | 70% |
| å¥‡é—¨ | ~1200 è¡Œ | ~400 è¡Œ | 67% |
| å…¶ä»–6ä¸ªæ¨¡å— | ~6000 è¡Œ | ~1500 è¡Œ | 75% |
| **æ€»è®¡** | ~8200 è¡Œ | ~2200 è¡Œ | **73%** |

---

## æ¨¡å—æ³¨å†Œæœºåˆ¶ï¼ˆæ’ä»¶åŒ–è®¾è®¡ï¼‰

ä¸ºæ”¯æŒä»»æ„æ•°é‡çš„å åœæ¨¡å—åŠ¨æ€æ‰©å±•ï¼Œé‡‡ç”¨**æ³¨å†Œè¡¨æ¨¡å¼**ã€‚

### è®¾è®¡åŸåˆ™

1. **å¼€æ”¾å°é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
2. **é›¶ä»£ç ä¾µå…¥**ï¼šæ–°æ¨¡å—æ— éœ€ä¿®æ”¹é€šç”¨å±‚ä»£ç 
3. **è¿è¡Œæ—¶æ³¨å†Œ**ï¼šæ¨¡å—åœ¨ runtime é…ç½®æ—¶è‡ªåŠ¨æ³¨å†Œ
4. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥æ¨¡å—å®ç°

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         æ¨¡å—æ³¨å†Œæœºåˆ¶                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    DivinationRegistry                            â”‚    â”‚
â”‚  â”‚                    (æ¨¡å—æ³¨å†Œè¡¨)                                  â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚  register<M: DivinationModule>()                                â”‚    â”‚
â”‚  â”‚  get_module(type: DivinationType) -> Option<&dyn Module>        â”‚    â”‚
â”‚  â”‚  list_modules() -> Vec<DivinationType>                          â”‚    â”‚
â”‚  â”‚  is_registered(type: DivinationType) -> bool                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                              â”‚                                           â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚              â–¼               â–¼               â–¼               â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”    â”‚
â”‚  â”‚ BaZiModule      â”‚ â”‚ QiMenModule     â”‚ â”‚ ZiWeiModule     â”‚ â”‚ ...â”‚    â”‚
â”‚  â”‚ impl Module     â”‚ â”‚ impl Module     â”‚ â”‚ impl Module     â”‚ â”‚    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒ Trait å®šä¹‰

```rust
//! # æ¨¡å—æ³¨å†Œæœºåˆ¶
//!
//! æ”¯æŒä»»æ„å åœæ¨¡å—çš„åŠ¨æ€æ³¨å†Œå’Œæ‰©å±•ã€‚

use crate::types::*;
use frame_support::dispatch::DispatchResult;
use sp_std::prelude::*;

/// å åœæ¨¡å— Traitï¼ˆæ‰€æœ‰æ¨¡å—å¿…é¡»å®ç°ï¼‰
///
/// è¿™æ˜¯æ¨¡å—æ³¨å†Œçš„æ ¸å¿ƒæ¥å£ï¼Œå®šä¹‰äº†æ¨¡å—éœ€è¦æä¾›çš„æ‰€æœ‰èƒ½åŠ›ã€‚
pub trait DivinationModule<T: Config> {
    /// æ¨¡å—å”¯ä¸€æ ‡è¯†
    const MODULE_ID: DivinationType;
    
    /// æ¨¡å—åç§°ï¼ˆç”¨äºæ—¥å¿—å’Œè°ƒè¯•ï¼‰
    const MODULE_NAME: &'static str;
    
    /// æ¨¡å—ç‰ˆæœ¬
    const VERSION: u32;
    
    /// è¾“å…¥ç±»å‹ï¼ˆæ˜æ–‡ï¼‰
    type PlainInput: Clone + Encode + Decode + TypeInfo + MaxEncodedLen;
    
    /// ç´¢å¼•ç±»å‹ï¼ˆé“¾ä¸Šå­˜å‚¨çš„æœ€å°åŒ–æ•°æ®ï¼‰
    type Index: Clone + Encode + Decode + TypeInfo + MaxEncodedLen;
    
    /// è®¡ç®—ç»“æœç±»å‹
    type Result: Clone + Encode + Decode;
    
    /// é…ç½®ç±»å‹ï¼ˆæ¨¡å—ç‰¹å®šé…ç½®ï¼‰
    type ModuleConfig: ModuleConfiguration;
    
    // ==================== æ ¸å¿ƒæ–¹æ³• ====================
    
    /// æ‰§è¡Œè®¡ç®—
    fn compute(input: &Self::PlainInput) -> Result<Self::Result, ModuleError>;
    
    /// ä»è®¡ç®—ç»“æœæå–ç´¢å¼•
    fn extract_index(result: &Self::Result, privacy_mode: PrivacyMode) -> Option<Self::Index>;
    
    /// ç”Ÿæˆ JSON æ¸…å•
    fn generate_manifest(
        input: &Self::PlainInput,
        result: &Self::Result,
        privacy_mode: PrivacyMode,
    ) -> Result<Vec<u8>, ModuleError>;
    
    /// éªŒè¯è¾“å…¥æœ‰æ•ˆæ€§
    fn validate_input(input: &Self::PlainInput) -> Result<(), ModuleError>;
    
    // ==================== å¯é€‰æ–¹æ³•ï¼ˆæœ‰é»˜è®¤å®ç°ï¼‰====================
    
    /// è·å–æ¨èè¶…æ—¶æ—¶é—´ï¼ˆåŒºå—æ•°ï¼‰
    fn recommended_timeout() -> u32 {
        Self::MODULE_ID.recommended_timeout()
    }
    
    /// è·å–æœ€å¤§è¾“å…¥å¤§å°
    fn max_input_size() -> u32 {
        256
    }
    
    /// æ˜¯å¦æ”¯æŒæ‰¹é‡å¤„ç†
    fn supports_batch() -> bool {
        false
    }
    
    /// è·å– TEE ç«¯ç‚¹è·¯å¾„
    fn tee_endpoint() -> &'static str {
        Self::MODULE_ID.tee_endpoint()
    }
    
    /// æ¨¡å—åˆå§‹åŒ–é’©å­ï¼ˆruntime å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
    fn on_initialize() -> Weight {
        Weight::zero()
    }
    
    /// æ¨¡å—æ¸…ç†é’©å­ï¼ˆruntime å…³é—­æ—¶è°ƒç”¨ï¼‰
    fn on_finalize() {
        // é»˜è®¤æ— æ“ä½œ
    }
}

/// æ¨¡å—é…ç½® Trait
pub trait ModuleConfiguration {
    /// è·å–é…ç½®å€¼
    fn get<V: Decode>(key: &str) -> Option<V>;
    
    /// è®¾ç½®é…ç½®å€¼
    fn set<V: Encode>(key: &str, value: V);
}

/// æ¨¡å—é”™è¯¯ç±»å‹
#[derive(Clone, Debug, Encode, Decode, TypeInfo)]
pub enum ModuleError {
    /// è¾“å…¥æ— æ•ˆ
    InvalidInput(BoundedVec<u8, ConstU32<128>>),
    /// è®¡ç®—å¤±è´¥
    ComputationFailed(BoundedVec<u8, ConstU32<128>>),
    /// åºåˆ—åŒ–å¤±è´¥
    SerializationFailed,
    /// æ¨¡å—æœªæ³¨å†Œ
    ModuleNotRegistered,
    /// é…ç½®é”™è¯¯
    ConfigurationError,
    /// å…¶ä»–é”™è¯¯
    Other(BoundedVec<u8, ConstU32<128>>),
}
```

### æ¨¡å—æ³¨å†Œè¡¨å®ç°

```rust
//! # æ¨¡å—æ³¨å†Œè¡¨
//!
//! ç®¡ç†æ‰€æœ‰å·²æ³¨å†Œçš„å åœæ¨¡å—ã€‚

use sp_std::collections::btree_map::BTreeMap;

/// æ¨¡å—æ³¨å†Œè¡¨
pub struct DivinationRegistry<T: Config> {
    /// å·²æ³¨å†Œæ¨¡å—
    modules: BTreeMap<DivinationType, Box<dyn ModuleHandler<T>>>,
}

impl<T: Config> DivinationRegistry<T> {
    /// åˆ›å»ºæ–°çš„æ³¨å†Œè¡¨
    pub fn new() -> Self {
        Self {
            modules: BTreeMap::new(),
        }
    }
    
    /// æ³¨å†Œæ¨¡å—
    pub fn register<M: DivinationModule<T> + 'static>(&mut self) -> Result<(), &'static str> {
        let module_id = M::MODULE_ID;
        
        if self.modules.contains_key(&module_id) {
            return Err("Module already registered");
        }
        
        log::info!(
            "ğŸ“¦ Registering divination module: {} (v{})",
            M::MODULE_NAME,
            M::VERSION
        );
        
        self.modules.insert(module_id, Box::new(ModuleWrapper::<T, M>::new()));
        
        Ok(())
    }
    
    /// è·å–æ¨¡å—å¤„ç†å™¨
    pub fn get(&self, module_id: DivinationType) -> Option<&dyn ModuleHandler<T>> {
        self.modules.get(&module_id).map(|m| m.as_ref())
    }
    
    /// åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œæ¨¡å—
    pub fn list(&self) -> Vec<DivinationType> {
        self.modules.keys().cloned().collect()
    }
    
    /// æ£€æŸ¥æ¨¡å—æ˜¯å¦å·²æ³¨å†Œ
    pub fn is_registered(&self, module_id: DivinationType) -> bool {
        self.modules.contains_key(&module_id)
    }
    
    /// è·å–å·²æ³¨å†Œæ¨¡å—æ•°é‡
    pub fn count(&self) -> usize {
        self.modules.len()
    }
}

/// æ¨¡å—å¤„ç†å™¨ Traitï¼ˆç±»å‹æ“¦é™¤ï¼‰
pub trait ModuleHandler<T: Config>: Send + Sync {
    /// è·å–æ¨¡å— ID
    fn module_id(&self) -> DivinationType;
    
    /// è·å–æ¨¡å—åç§°
    fn module_name(&self) -> &'static str;
    
    /// å¤„ç†è¯·æ±‚ï¼ˆé€šç”¨å…¥å£ï¼‰
    fn handle_request(
        &self,
        input_data: &[u8],
        privacy_mode: PrivacyMode,
    ) -> Result<ProcessResult, ModuleError>;
    
    /// è·å–æ¨èè¶…æ—¶
    fn recommended_timeout(&self) -> u32;
}

/// æ¨¡å—åŒ…è£…å™¨ï¼ˆæ¡¥æ¥æ³›å‹å’Œ trait objectï¼‰
struct ModuleWrapper<T: Config, M: DivinationModule<T>> {
    _phantom: sp_std::marker::PhantomData<(T, M)>,
}

impl<T: Config, M: DivinationModule<T>> ModuleWrapper<T, M> {
    fn new() -> Self {
        Self {
            _phantom: sp_std::marker::PhantomData,
        }
    }
}

impl<T: Config, M: DivinationModule<T>> ModuleHandler<T> for ModuleWrapper<T, M> {
    fn module_id(&self) -> DivinationType {
        M::MODULE_ID
    }
    
    fn module_name(&self) -> &'static str {
        M::MODULE_NAME
    }
    
    fn handle_request(
        &self,
        input_data: &[u8],
        privacy_mode: PrivacyMode,
    ) -> Result<ProcessResult, ModuleError> {
        // 1. è§£ç è¾“å…¥
        let input = M::PlainInput::decode(&mut &input_data[..])
            .map_err(|_| ModuleError::InvalidInput(b"Decode failed".to_vec().try_into().unwrap()))?;
        
        // 2. éªŒè¯è¾“å…¥
        M::validate_input(&input)?;
        
        // 3. æ‰§è¡Œè®¡ç®—
        let result = M::compute(&input)?;
        
        // 4. æå–ç´¢å¼•
        let type_index = M::extract_index(&result, privacy_mode)
            .map(|idx| idx.encode());
        
        // 5. ç”Ÿæˆæ¸…å•
        let manifest = M::generate_manifest(&input, &result, privacy_mode)?;
        let manifest_hash = sp_io::hashing::blake2_256(&manifest);
        
        Ok(ProcessResult {
            manifest_cid: Vec::new(), // ç”±è°ƒç”¨æ–¹ä¸Šä¼  IPFS åå¡«å……
            manifest_hash,
            type_index,
            proof: None,
            manifest_data: Some(manifest),
        })
    }
    
    fn recommended_timeout(&self) -> u32 {
        M::recommended_timeout()
    }
}
```

### Runtime é…ç½®ç¤ºä¾‹

```rust
//! # Runtime æ¨¡å—æ³¨å†Œ
//!
//! åœ¨ runtime ä¸­æ³¨å†Œæ‰€æœ‰å åœæ¨¡å—ã€‚

// runtime/src/lib.rs

use pallet_divination_ocw_tee::{
    DivinationRegistry,
    DivinationModule,
};

/// åˆå§‹åŒ–æ¨¡å—æ³¨å†Œè¡¨
pub fn init_divination_registry() -> DivinationRegistry<Runtime> {
    let mut registry = DivinationRegistry::new();
    
    // æ³¨å†Œå…«å­—æ¨¡å—
    registry.register::<pallet_divination_bazi::Pallet<Runtime>>()
        .expect("Failed to register BaZi module");
    
    // æ³¨å†Œå¥‡é—¨æ¨¡å—
    registry.register::<pallet_divination_qimen::Pallet<Runtime>>()
        .expect("Failed to register QiMen module");
    
    // æ³¨å†Œæ¢…èŠ±æ˜“æ•°æ¨¡å—
    registry.register::<pallet_divination_meihua::Pallet<Runtime>>()
        .expect("Failed to register MeiHua module");
    
    // æ³¨å†Œå…­çˆ»æ¨¡å—
    registry.register::<pallet_divination_liuyao::Pallet<Runtime>>()
        .expect("Failed to register LiuYao module");
    
    // æ³¨å†Œç´«å¾®æ–—æ•°æ¨¡å—
    registry.register::<pallet_divination_ziwei::Pallet<Runtime>>()
        .expect("Failed to register ZiWei module");
    
    // æ³¨å†Œå¤§å…­å£¬æ¨¡å—
    registry.register::<pallet_divination_daliuren::Pallet<Runtime>>()
        .expect("Failed to register DaLiuRen module");
    
    // æ³¨å†Œå°å…­å£¬æ¨¡å—
    registry.register::<pallet_divination_xiaoliuren::Pallet<Runtime>>()
        .expect("Failed to register XiaoLiuRen module");
    
    // æ³¨å†Œå¡”ç½—æ¨¡å—
    registry.register::<pallet_divination_tarot::Pallet<Runtime>>()
        .expect("Failed to register Tarot module");
    
    log::info!("âœ… Registered {} divination modules", registry.count());
    
    registry
}

// åœ¨ runtime é…ç½®ä¸­ä½¿ç”¨
impl pallet_divination_ocw_tee::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Registry = DivinationRegistry<Runtime>;
    // ...
}
```

### æ–°æ¨¡å—æ¥å…¥æŒ‡å—

æ·»åŠ æ–°çš„å åœæ¨¡å—åªéœ€ **3 æ­¥**ï¼š

#### Step 1: å®ç° DivinationModule Trait

```rust
// pallets/divination/new-module/src/lib.rs

use pallet_divination_ocw_tee::{
    DivinationModule, DivinationType, PrivacyMode, ModuleError,
};

impl<T: Config> DivinationModule<T> for Pallet<T> {
    const MODULE_ID: DivinationType = DivinationType::NewModule;
    const MODULE_NAME: &'static str = "NewModule";
    const VERSION: u32 = 1;
    
    type PlainInput = NewModuleInput;
    type Index = NewModuleIndex;
    type Result = NewModuleResult;
    type ModuleConfig = DefaultModuleConfig;
    
    fn compute(input: &Self::PlainInput) -> Result<Self::Result, ModuleError> {
        // å®ç°è®¡ç®—é€»è¾‘
        todo!()
    }
    
    fn extract_index(result: &Self::Result, privacy_mode: PrivacyMode) -> Option<Self::Index> {
        match privacy_mode {
            PrivacyMode::Private => None,
            _ => Some(result.to_index()),
        }
    }
    
    fn generate_manifest(
        input: &Self::PlainInput,
        result: &Self::Result,
        privacy_mode: PrivacyMode,
    ) -> Result<Vec<u8>, ModuleError> {
        // ç”Ÿæˆ JSON æ¸…å•
        todo!()
    }
    
    fn validate_input(input: &Self::PlainInput) -> Result<(), ModuleError> {
        // éªŒè¯è¾“å…¥
        Ok(())
    }
}
```

#### Step 2: æ·»åŠ  DivinationType æšä¸¾å€¼

```rust
// pallet-divination-ocw-tee/src/types.rs

pub enum DivinationType {
    BaZi = 0,
    QiMen = 1,
    // ...
    NewModule = 8,  // æ–°å¢
}

impl DivinationType {
    pub fn tee_endpoint(&self) -> &'static str {
        match self {
            // ...
            Self::NewModule => "/compute/newmodule",
        }
    }
}
```

#### Step 3: åœ¨ Runtime æ³¨å†Œ

```rust
// runtime/src/lib.rs

registry.register::<pallet_divination_newmodule::Pallet<Runtime>>()
    .expect("Failed to register NewModule");
```

**å®Œæˆï¼** æ–°æ¨¡å—è‡ªåŠ¨è·å¾—ï¼š
- âœ… OCW è°ƒåº¦æ”¯æŒ
- âœ… TEE éšç§è®¡ç®—
- âœ… IPFS å­˜å‚¨
- âœ… é‡è¯•æœºåˆ¶
- âœ… è¶…æ—¶å¤„ç†
- âœ… å‰ç«¯ SDK æ”¯æŒ

---

## æ‰©å±•ç‚¹è®¾è®¡

### 1. è‡ªå®šä¹‰è®¡ç®—è¶…æ—¶

```rust
impl<T: Config> DivinationModule<T> for Pallet<T> {
    // ...
    
    fn recommended_timeout() -> u32 {
        200  // è¦†ç›–é»˜è®¤å€¼
    }
}
```

### 2. è‡ªå®šä¹‰è¾“å…¥éªŒè¯

```rust
fn validate_input(input: &Self::PlainInput) -> Result<(), ModuleError> {
    if input.year < 1900 || input.year > 2100 {
        return Err(ModuleError::InvalidInput(
            b"Year out of range".to_vec().try_into().unwrap()
        ));
    }
    Ok(())
}
```

### 3. æ‰¹é‡å¤„ç†æ”¯æŒ

```rust
impl<T: Config> DivinationModule<T> for Pallet<T> {
    fn supports_batch() -> bool {
        true
    }
    
    fn compute_batch(inputs: &[Self::PlainInput]) -> Result<Vec<Self::Result>, ModuleError> {
        inputs.iter().map(Self::compute).collect()
    }
}
```

### 4. æ¨¡å—ç‰¹å®šäº‹ä»¶

```rust
// æ¨¡å—å¯ä»¥å®šä¹‰è‡ªå·±çš„äº‹ä»¶
#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event<T: Config> {
    /// å…«å­—è®¡ç®—å®Œæˆ
    BaziComputed {
        owner: T::AccountId,
        chart_id: u64,
        sizhu_index: SiZhuIndex,
    },
}
```

### 5. æ¨¡å—ç‰¹å®šå­˜å‚¨

```rust
// æ¨¡å—å¯ä»¥æœ‰è‡ªå·±çš„é¢å¤–å­˜å‚¨
#[pallet::storage]
pub type BaziCharts<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    u64,
    BaziOnChain<T>,
    OptionQuery,
>;
```

---

## æ¨¡å—ç”Ÿå‘½å‘¨æœŸ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         æ¨¡å—ç”Ÿå‘½å‘¨æœŸ                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  1. ç¼–è¯‘æ—¶                                                               â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚     â”‚ impl DivinationModule<T> for Pallet<T>                      â”‚     â”‚
â”‚     â”‚   - ç±»å‹æ£€æŸ¥                                                â”‚     â”‚
â”‚     â”‚   - Trait çº¦æŸéªŒè¯                                          â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                           â”‚
â”‚                              â–¼                                           â”‚
â”‚  2. Runtime åˆå§‹åŒ–                                                       â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚     â”‚ registry.register::<Pallet<Runtime>>()                      â”‚     â”‚
â”‚     â”‚   - æ³¨å†Œåˆ°å…¨å±€æ³¨å†Œè¡¨                                        â”‚     â”‚
â”‚     â”‚   - è°ƒç”¨ on_initialize()                                    â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                           â”‚
â”‚                              â–¼                                           â”‚
â”‚  3. è¯·æ±‚å¤„ç†                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚     â”‚ OCW è°ƒåº¦å™¨                                                  â”‚     â”‚
â”‚     â”‚   - æ ¹æ® divination_type æŸ¥æ‰¾æ¨¡å—                           â”‚     â”‚
â”‚     â”‚   - è°ƒç”¨ handle_request()                                   â”‚     â”‚
â”‚     â”‚   - å¤„ç†ç»“æœ/é”™è¯¯                                           â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â”‚                                           â”‚
â”‚                              â–¼                                           â”‚
â”‚  4. Runtime å…³é—­                                                         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚     â”‚ è°ƒç”¨ on_finalize()                                          â”‚     â”‚
â”‚     â”‚   - æ¸…ç†èµ„æº                                                â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å‚è€ƒ

- `docs/BAZI_JSON_MANIFEST_DESIGN.md` - å…«å­— JSON æ¸…å•è®¾è®¡
- `docs/QIMEN_JSON_MANIFEST_DESIGN.md` - å¥‡é—¨ JSON æ¸…å•è®¾è®¡
- `docs/OPTIMAL_DEVELOPMENT_PLAN.md` - æœ€ä¼˜å¼€å‘æ–¹æ¡ˆ
- `pallets/divination/tee-privacy/src/lib.rs` - TEE éšç§è®¡ç®—æ¨¡å—
- `pallets/stardust-ipfs/src/lib.rs` - IPFS é›†æˆæ¨¡å—
