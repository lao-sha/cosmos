use crate::mock::*;
use crate::pallet::*;
use frame_support::{assert_noop, assert_ok};
use pallet_entity_common::MallOrderStatus;

// ==================== place_order ====================

#[test]
fn place_order_physical_works() {
    new_test_ext().execute_with(|| {
        // Product 1 = Physical, shop 1, price 100
        assert_ok!(Transaction::place_order(
            RuntimeOrigin::signed(BUYER),
            1, // product_id
            2, // quantity
            Some(b"addr_cid".to_vec()),
            None,
        ));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.buyer, BUYER);
        assert_eq!(order.seller, SELLER);
        assert_eq!(order.quantity, 2);
        assert_eq!(order.unit_price, 100);
        assert_eq!(order.total_amount, 200); // 100 * 2
        assert_eq!(order.status, MallOrderStatus::Paid);
        assert!(order.requires_shipping);
        assert_eq!(order.escrow_id, 1);
    });
}

#[test]
fn place_order_digital_auto_completes() {
    new_test_ext().execute_with(|| {
        // Product 2 = Digital, shop 1, price 50
        assert_ok!(Transaction::place_order(
            RuntimeOrigin::signed(BUYER),
            2, // digital product
            1,
            None,
            None,
        ));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Completed);
        assert!(order.completed_at.is_some());
        assert!(!order.requires_shipping);
    });
}

#[test]
fn place_order_service_works() {
    new_test_ext().execute_with(|| {
        // Product 3 = Service, shop 1, price 200
        assert_ok!(Transaction::place_order(
            RuntimeOrigin::signed(BUYER),
            3,
            1,
            None,
            None,
        ));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Paid);
        assert!(!order.requires_shipping);
        assert_eq!(order.product_category, pallet_entity_common::ProductCategory::Service);
    });
}

#[test]
fn place_order_fails_zero_quantity() {
    new_test_ext().execute_with(|| {
        assert_noop!(
            Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 0, None, None),
            Error::<Test>::InvalidQuantity
        );
    });
}

#[test]
fn place_order_fails_product_not_found() {
    new_test_ext().execute_with(|| {
        assert_noop!(
            Transaction::place_order(RuntimeOrigin::signed(BUYER), 99, 1, None, None),
            Error::<Test>::ProductNotFound
        );
    });
}

#[test]
fn place_order_fails_buy_own_product() {
    new_test_ext().execute_with(|| {
        // SELLER owns shop 1, product 1 belongs to shop 1
        assert_noop!(
            Transaction::place_order(RuntimeOrigin::signed(SELLER), 1, 1, None, None),
            Error::<Test>::CannotBuyOwnProduct
        );
    });
}

// ==================== cancel_order ====================

#[test]
fn cancel_order_works() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_ok!(Transaction::cancel_order(RuntimeOrigin::signed(BUYER), 1));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Cancelled);

        // C3: on_order_cancelled was called
        assert_eq!(get_cancelled_orders(), vec![1]);
    });
}

#[test]
fn cancel_order_fails_digital() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 2, 1, None, None));

        assert_noop!(
            Transaction::cancel_order(RuntimeOrigin::signed(BUYER), 1),
            Error::<Test>::DigitalProductCannotCancel
        );
    });
}

#[test]
fn cancel_order_fails_not_buyer() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_noop!(
            Transaction::cancel_order(RuntimeOrigin::signed(BUYER2), 1),
            Error::<Test>::NotOrderBuyer
        );
    });
}

#[test]
fn cancel_order_fails_after_shipped() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"track123".to_vec()));

        assert_noop!(
            Transaction::cancel_order(RuntimeOrigin::signed(BUYER), 1),
            Error::<Test>::CannotCancelOrder
        );
    });
}

// ==================== ship_order ====================

#[test]
fn ship_order_works() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"track_cid".to_vec()));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Shipped);
        assert!(order.shipped_at.is_some());
        assert!(order.tracking_cid.is_some());
    });
}

#[test]
fn ship_order_fails_not_seller() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_noop!(
            Transaction::ship_order(RuntimeOrigin::signed(BUYER), 1, b"track".to_vec()),
            Error::<Test>::NotOrderSeller
        );
    });
}

// ==================== confirm_receipt ====================

#[test]
fn confirm_receipt_works() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"track".to_vec()));
        assert_ok!(Transaction::confirm_receipt(RuntimeOrigin::signed(BUYER), 1));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Completed);
        assert!(order.completed_at.is_some());

        // Check stats
        let stats = Transaction::order_stats();
        assert_eq!(stats.completed_orders, 1);
    });
}

#[test]
fn confirm_receipt_fails_not_shipped() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_noop!(
            Transaction::confirm_receipt(RuntimeOrigin::signed(BUYER), 1),
            Error::<Test>::InvalidOrderStatus
        );
    });
}

// ==================== request_refund / approve_refund ====================

#[test]
fn request_refund_works() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_ok!(Transaction::request_refund(
            RuntimeOrigin::signed(BUYER), 1, b"reason".to_vec()
        ));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Disputed);
    });
}

#[test]
fn request_refund_fails_digital() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 2, 1, None, None));

        assert_noop!(
            Transaction::request_refund(RuntimeOrigin::signed(BUYER), 1, b"reason".to_vec()),
            Error::<Test>::DigitalProductCannotRefund
        );
    });
}

#[test]
fn approve_refund_works() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::request_refund(RuntimeOrigin::signed(BUYER), 1, b"reason".to_vec()));
        assert_ok!(Transaction::approve_refund(RuntimeOrigin::signed(SELLER), 1));

        let order = Transaction::orders(1).expect("order should exist");
        assert_eq!(order.status, MallOrderStatus::Refunded);

        // C3: on_order_cancelled was called
        assert_eq!(get_cancelled_orders(), vec![1]);
    });
}

#[test]
fn approve_refund_fails_not_seller() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::request_refund(RuntimeOrigin::signed(BUYER), 1, b"reason".to_vec()));

        assert_noop!(
            Transaction::approve_refund(RuntimeOrigin::signed(BUYER), 1),
            Error::<Test>::NotOrderSeller
        );
    });
}

// ==================== Service order flow ====================

#[test]
fn service_order_full_flow() {
    new_test_ext().execute_with(|| {
        // Product 3 = Service
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 3, 1, None, None));

        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Paid);

        // Start service
        assert_ok!(Transaction::start_service(RuntimeOrigin::signed(SELLER), 1));
        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Shipped);
        assert!(order.service_started_at.is_some());

        // Complete service
        assert_ok!(Transaction::complete_service(RuntimeOrigin::signed(SELLER), 1));
        let order = Transaction::orders(1).unwrap();
        assert!(order.service_completed_at.is_some());

        // Confirm service
        assert_ok!(Transaction::confirm_service(RuntimeOrigin::signed(BUYER), 1));
        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Completed);
    });
}

#[test]
fn start_service_fails_not_service_order() {
    new_test_ext().execute_with(|| {
        // Product 1 = Physical
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert_noop!(
            Transaction::start_service(RuntimeOrigin::signed(SELLER), 1),
            Error::<Test>::NotServiceOrder
        );
    });
}

#[test]
fn confirm_service_fails_without_completion() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 3, 1, None, None));
        assert_ok!(Transaction::start_service(RuntimeOrigin::signed(SELLER), 1));

        // service_completed_at is None â†’ should fail
        assert_noop!(
            Transaction::confirm_service(RuntimeOrigin::signed(BUYER), 1),
            Error::<Test>::InvalidOrderStatus
        );
    });
}

// ==================== Timeout processing ====================

#[test]
fn ship_timeout_auto_refunds() {
    new_test_ext().execute_with(|| {
        // Physical product, ShipTimeout = 100 blocks
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_eq!(Transaction::orders(1).unwrap().status, MallOrderStatus::Paid);

        // Advance to block 1 + 100 = 101
        run_to_block(101);

        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Refunded);

        // C3: on_order_cancelled was called by timeout handler
        assert!(get_cancelled_orders().contains(&1));
    });
}

#[test]
fn confirm_timeout_auto_completes() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"track".to_vec()));

        // shipped_at = 1, ConfirmTimeout = 200, expiry = 1 + 200 = 201
        run_to_block(201);

        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Completed);
    });
}

#[test]
fn service_timeout_auto_refunds() {
    new_test_ext().execute_with(|| {
        // Service product, ShipTimeout = 100
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 3, 1, None, None));

        // Don't start service, wait for timeout
        run_to_block(101);

        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.status, MallOrderStatus::Refunded);
    });
}

// ==================== OrderProvider trait ====================

#[test]
fn order_provider_trait_works() {
    new_test_ext().execute_with(|| {
        use pallet_entity_common::OrderProvider;

        assert!(!<Transaction as OrderProvider<u64, u64>>::order_exists(1));

        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        assert!(<Transaction as OrderProvider<u64, u64>>::order_exists(1));
        assert_eq!(<Transaction as OrderProvider<u64, u64>>::order_buyer(1), Some(BUYER));
        assert_eq!(<Transaction as OrderProvider<u64, u64>>::order_shop_id(1), Some(SHOP_1));
        assert!(!<Transaction as OrderProvider<u64, u64>>::is_order_completed(1));

        // Ship and confirm
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"t".to_vec()));
        assert_ok!(Transaction::confirm_receipt(RuntimeOrigin::signed(BUYER), 1));
        assert!(<Transaction as OrderProvider<u64, u64>>::is_order_completed(1));
    });
}

// ==================== Statistics ====================

#[test]
fn order_stats_tracking() {
    new_test_ext().execute_with(|| {
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 2, None, None));

        let stats = Transaction::order_stats();
        assert_eq!(stats.total_orders, 2);
        assert_eq!(stats.completed_orders, 0);

        // Complete first order
        assert_ok!(Transaction::ship_order(RuntimeOrigin::signed(SELLER), 1, b"t".to_vec()));
        assert_ok!(Transaction::confirm_receipt(RuntimeOrigin::signed(BUYER), 1));

        let stats = Transaction::order_stats();
        assert_eq!(stats.completed_orders, 1);
    });
}

// ==================== Platform fee ====================

#[test]
fn platform_fee_calculated_correctly() {
    new_test_ext().execute_with(|| {
        // Price 100 * qty 1 = 100, platform_fee = 100 * 200 / 10000 = 2
        assert_ok!(Transaction::place_order(RuntimeOrigin::signed(BUYER), 1, 1, None, None));

        let order = Transaction::orders(1).unwrap();
        assert_eq!(order.total_amount, 100);
        assert_eq!(order.platform_fee, 2);
    });
}
